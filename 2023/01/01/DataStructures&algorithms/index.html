<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构和算法题 data structures&amp; algorothms | HELLO WORLD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="PythonDataStructures&Algorothms" />
  
  
  
  
  <meta name="description" content="leetcode题目–leetcode刷题记录–">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法题 Data Structures&amp; Algorothms">
<meta property="og:url" content="http://example.com/2023/01/01/DataStructures&algorithms/index.html">
<meta property="og:site_name" content="HELLO WORLD">
<meta property="og:description" content="leetcode题目–leetcode刷题记录–">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
<meta property="article:published_time" content="2023-01-01T02:10:12.000Z">
<meta property="article:modified_time" content="2023-09-19T09:18:30.333Z">
<meta property="article:author" content="Bai Xiong">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="DataStructures&amp;Algorothms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
  
    <link rel="alternate" href="/atom.xml" title="HELLO WORLD" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 5.4.2"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li> <a class="main-nav-link" href="/collection">collection</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      

      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-DataStructures&amp;algorithms" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      数据结构和算法题 Data Structures&amp; Algorothms
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/01/01/DataStructures&algorithms/" class="article-date">
	  <time datetime="2023-01-01T02:10:12.000Z" itemprop="datePublished">2023-01-01</time>
	</a>

      
    <a class="article-category-link" href="/categories/Code/">Code</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="leetcode题目"><a href="#leetcode题目" class="headerlink" title="leetcode题目"></a>leetcode题目</h3><p>–leetcode刷题记录–</p>
<span id="more"></span>


<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len, hashmap=<span class="number">0</span>,&#123;&#125;</span><br><span class="line">        start =<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) == end-start +<span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> end-start+<span class="number">1</span> &gt;<span class="built_in">len</span>(hashmap):</span><br><span class="line">                hashmap[s[start]] -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[s[start]]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[s[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        i, j, res = 0, len(height)-1, 0</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            if height[i]&lt;=height[j]:</span><br><span class="line">                res = max(res, height[i]*(j-i))</span><br><span class="line">                i += 1</span><br><span class="line">            elif height[i]&gt;height[j]:</span><br><span class="line">                res = max(res, height[j]*(j-i))</span><br><span class="line">                j -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请<br>你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment"># 1. because of j &gt; i &gt; k.</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment"># 2. skip the same `nums[k]`.</span></span><br><span class="line">            i, j = k + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j: <span class="comment"># 3. double pointer</span></span><br><span class="line">                s = nums[k] + nums[i] + nums[j]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># dic = &#123;&#x27;&#123;&#x27;:&#x27;&#125;&#x27;,&#x27;[&#x27;:&#x27;]&#x27;,&#x27;(&#x27;:&#x27;)&#x27;&#125;</span></span><br><span class="line">        dic = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] == dic[i]: stack.pop()</span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def isValid(self, s: str) -&gt; bool:</span></span><br><span class="line"><span class="comment">#         dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125;</span></span><br><span class="line"><span class="comment">#         stack = []</span></span><br><span class="line"><span class="comment">#         for i in s:</span></span><br><span class="line"><span class="comment">#             if stack and i in dic:</span></span><br><span class="line"><span class="comment">#                 if stack[-1] == dic[i]: stack.pop()</span></span><br><span class="line"><span class="comment">#                 else: return False</span></span><br><span class="line"><span class="comment">#             else: stack.append(i)</span></span><br><span class="line"><span class="comment">#         return not stack</span></span><br></pre></td></tr></table></figure>
<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1,l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="26-删除有效数组中的重复项"><a href="#26-删除有效数组中的重复项" class="headerlink" title="26.删除有效数组中的重复项"></a>26.删除有效数组中的重复项</h4><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。<br>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：<br>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。<br>判题标准:<br>系统会用下面的代码来测试你的题解:<br>int[] nums = […]; // 输入数组<br>int[] expectedNums = […]; // 长度正确的期望答案<br>int k = removeDuplicates(nums); // 调用<br>assert k == expectedNums.length;<br>for (int i = 0; i &lt; k; i++) {<br>    assert nums[i] == expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow = slow + <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast = fast + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        min_index = nums.index(min(nums))</span><br><span class="line">        nums_ = nums[min_index:]+nums[:min_index]</span><br><span class="line"></span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums_)-1</span><br><span class="line">        while low &lt;= high:</span><br><span class="line">            mid = (low + high)</span><br><span class="line">            guess = nums_[mid]</span><br><span class="line">            if guess == target:</span><br><span class="line">                return nums.index(nums_[mid])</span><br><span class="line">            if guess &gt; target:</span><br><span class="line">                high = mid - 1</span><br><span class="line">            else:</span><br><span class="line">                low = mid + 1</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h4><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binarySearchLeft</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;<span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            l = -<span class="number">1</span></span><br><span class="line">            r = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> l+<span class="number">1</span> != r :</span><br><span class="line">                mid = l+(r-l)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target :</span><br><span class="line">                    r = mid</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    l = mid</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binarySearchRight</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;<span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            l = -<span class="number">1</span></span><br><span class="line">            r = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> l+<span class="number">1</span> != r :</span><br><span class="line">                mid = l+(r-l)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target :</span><br><span class="line">                    l = mid</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    r = mid</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">        leftIdx = binarySearchLeft(nums, target)</span><br><span class="line">        rightIdx = binarySearchRight(nums, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftIdx&lt;=rightIdx <span class="keyword">and</span> rightIdx&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[leftIdx]==target <span class="keyword">and</span> nums[rightIdx]==target :</span><br><span class="line">            <span class="keyword">return</span> [leftIdx, rightIdx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h4><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res, path, used = [], [], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                dfs()</span><br><span class="line">                <span class="comment"># 回溯的过程中，将当前的节点从 path 中删除</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h4><p>给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        return bin(int(a,2)+int(b,2))[2:]</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &lt; n:</span><br><span class="line">            <span class="built_in">print</span>(s)</span><br><span class="line">            s.append(s[-<span class="number">1</span>] + s[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h4><p>给你一个满足下述两条属性的 m x n 整数矩阵：<br>每行中的整数从左到右按非递减顺序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> list_ <span class="keyword">in</span> matrix:</span><br><span class="line">            nums += list_</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high)</span><br><span class="line">            guess = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> guess == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> guess &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h4><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">tmp: <span class="built_in">list</span>, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == k:</span><br><span class="line">                ans.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n + <span class="number">1</span>):</span><br><span class="line">                tmp.append(i)</span><br><span class="line">                backtrack(tmp, i + <span class="number">1</span>)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        backtrack([], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


<h4 id="82-删除排序链表中的重复元素"><a href="#82-删除排序链表中的重复元素" class="headerlink" title="82.删除排序链表中的重复元素"></a>82.删除排序链表中的重复元素</h4><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val != head.<span class="built_in">next</span>.val:</span><br><span class="line">            head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            move = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> move <span class="keyword">and</span> head.val == move.val:</span><br><span class="line">                move = move.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(move)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a>83.删除排序链表中的重复元素</h4><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur =cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span></span><br><span class="line"><span class="comment">#         if head is None:</span></span><br><span class="line"><span class="comment">#             return None</span></span><br><span class="line"><span class="comment">#         cur = head</span></span><br><span class="line"><span class="comment">#         while cur.next:</span></span><br><span class="line"><span class="comment">#             if cur.next.val == cur.val:</span></span><br><span class="line"><span class="comment">#                 cur.next = cur.next.next</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 cur = cur.next</span></span><br><span class="line"><span class="comment">#         return head</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h4><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums1[:] = sorted(nums1[:m]+nums2)</span><br><span class="line">        # nums1[:] = sorted(nums1[:m] + nums2)</span><br></pre></td></tr></table></figure>

<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h4><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="111-二叉树的最大深度"><a href="#111-二叉树的最大深度" class="headerlink" title="111.二叉树的最大深度"></a>111.二叉树的最大深度</h4><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">min_tree_depth</span>(<span class="params">r</span>):</span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">None</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = min_tree_depth(r.left)</span><br><span class="line">            right = min_tree_depth(r.right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(l, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_tree_depth(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h4><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:</span><br><span class="line">        if root == None:</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        def BFS(oneLayer):</span><br><span class="line">            nextLayer = []   # 每一次都搞个空的列表，去建立nextLayer</span><br><span class="line">            for i in oneLayer:</span><br><span class="line">                if i.left:</span><br><span class="line">                    nextLayer.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    nextLayer.append(i.right)</span><br><span class="line"></span><br><span class="line">            if len(nextLayer) &gt; 1:  # 一共只有1个节点就没必要搞了。</span><br><span class="line">                for j in range(0, len(nextLayer) - 1):</span><br><span class="line">                    nextLayer[j].next = nextLayer[j + 1]  # 每个节点的next指向后面一个节点。</span><br><span class="line"></span><br><span class="line">            if nextLayer:  # nextLayer不是空的话就继续往下走。</span><br><span class="line">                BFS(nextLayer)</span><br><span class="line"></span><br><span class="line">        BFS([root])  # 最开始就是只有一层一个根节点。</span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针 II"></a>117.填充每个节点的下一个右侧节点指针 II</h4><p>给定一个二叉树：<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。<br>初始状态下，所有 next 指针都被设置为 NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:</span><br><span class="line">        if root == None:</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        def BFS(oneLayer):</span><br><span class="line">            nextLayer = []   # 每一次都搞个空的列表，去建立nextLayer</span><br><span class="line">            for i in oneLayer:</span><br><span class="line">                if i.left:</span><br><span class="line">                    nextLayer.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    nextLayer.append(i.right)</span><br><span class="line"></span><br><span class="line">            if len(nextLayer) &gt; 1:  # 一共只有1个节点就没必要搞了。</span><br><span class="line">                for j in range(0, len(nextLayer) - 1):</span><br><span class="line">                    nextLayer[j].next = nextLayer[j + 1]  # 每个节点的next指向后面一个节点。</span><br><span class="line"></span><br><span class="line">            if nextLayer:  # nextLayer不是空的话就继续往下走。</span><br><span class="line">                BFS(nextLayer)</span><br><span class="line"></span><br><span class="line">        BFS([root])  # 最开始就是只有一层一个根节点。</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>
<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120.三角形最小路径和"></a>120.三角形最小路径和</h4><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。<br>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i])):</span><br><span class="line">                triangle[i][j] = triangle[i][j] + <span class="built_in">min</span>(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>


<h4 id="136-只出现一次的数"><a href="#136-只出现一次的数" class="headerlink" title="136.只出现一次的数"></a>136.只出现一次的数</h4><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            n = nums.count(i)</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>


<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.寻找旋转排序数组中的最小值</h4><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums)</span><br></pre></td></tr></table></figure>


<h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162.寻找峰值"></a>162.寻找峰值</h4><p>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> nums.index(<span class="built_in">max</span>(nums))</span><br></pre></td></tr></table></figure>

<h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h4><p>颠倒给定的 32 位无符号整数的二进制位。<br>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        bits = <span class="built_in">bin</span>(n)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">        bits += <span class="string">&quot;0&quot;</span>*(<span class="number">32</span>-<span class="built_in">len</span>(bits))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(bits, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。<br>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次循环，计算“偷到当前房子为止的最大金额”</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">            <span class="comment"># dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;</span></span><br><span class="line">            prev, curr = curr, <span class="built_in">max</span>(curr, prev + i)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>


<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。<br>示例 1：<br>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：<br>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numIslands(self, grid: List[List[str]]) -&gt; int:</span><br><span class="line">        def dfs(grid,r,c):</span><br><span class="line">            if not 0&lt;=r&lt;len(grid) or not 0&lt;=c&lt;len(grid[0]):return</span><br><span class="line">            if grid[r][c]!=&quot;1&quot;:return  #注意题目这里输入的是字符&quot;0&quot;,“1”</span><br><span class="line">            grid[r][c]=&quot;2&quot;</span><br><span class="line">            dfs(grid,r-1,c)</span><br><span class="line">            dfs(grid,r+1,c)</span><br><span class="line">            dfs(grid,r,c-1)</span><br><span class="line">            dfs(grid,r,c+1)</span><br><span class="line">            return 1  #是岛屿,则返回1</span><br><span class="line"></span><br><span class="line">        res=0</span><br><span class="line">        for  r in range(len(grid)):</span><br><span class="line">            for c in range(len(grid[0])):</span><br><span class="line">                if grid[r][c]==&quot;1&quot;:</span><br><span class="line">                    res+=dfs(grid,r,c)  #累加岛屿的数量</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h4><p>给定两个字符串 s 和 t ，判断它们是否是同构的。<br>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return all(s.index(s[i]) == t.index(t[i])  for i in range(len(s)))</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): </span><br><span class="line">            <span class="keyword">if</span> s.index(s[i]) == t.index(t[i]): </span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        </span></span><br><span class="line">    <span class="comment">#     prev, curr = None, head</span></span><br><span class="line">    <span class="comment">#     while curr is not None:</span></span><br><span class="line">    <span class="comment">#         next = curr.next</span></span><br><span class="line">    <span class="comment">#         curr.next = prev</span></span><br><span class="line">    <span class="comment">#         prev = curr</span></span><br><span class="line">    <span class="comment">#         curr = next</span></span><br><span class="line">    <span class="comment">#     return prev</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。<br>示例 1：<br>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:</span><br><span class="line">        min_len, sum_ = math.inf, 0    # Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span><br><span class="line">        start = 0   # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            sum_ += nums[end]   # Step 3: 更新需要维护的变量 (min_len, sum_)</span><br><span class="line">            while sum_ &gt;= target:    # Step 4 这一题这里稍微有一点特别: sum_ &gt;= target其实是合法的，但由于我们要求的是最小长度，</span><br><span class="line">                min_len = min(min_len, end - start + 1)</span><br><span class="line">                sum_ -= nums[start]    </span><br><span class="line">                # 所以当sum_已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span><br><span class="line">                # 由于左指针的移动可能影响min_len和sum_的值，因此需要在移动前将它们更新</span><br><span class="line">                start += 1</span><br><span class="line">        if min_len == math.inf:   # Step 5：返回答案 (最小长度)</span><br><span class="line">            return 0</span><br><span class="line">        return min_len</span><br></pre></td></tr></table></figure>

<h4 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231.2的幂"></a>231.2的幂</h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。<br>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263.丑数"></a>263.丑数</h4><p>丑数 就是只包含质因数 2、3 和 5 的正整数。<br>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isUgly(self, n: int) -&gt; bool:</span><br><span class="line">        if n &lt;=0:</span><br><span class="line">            return False</span><br><span class="line">        while n % 2 == 0 :</span><br><span class="line">            n //= 2</span><br><span class="line">        while n % 3 == 0 :</span><br><span class="line">            n //= 3</span><br><span class="line">        while n % 5 == 0 :</span><br><span class="line">            n //= 5</span><br><span class="line">        return n ==1</span><br></pre></td></tr></table></figure>

<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h4><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> nums1 <span class="keyword">if</span> i <span class="keyword">in</span> nums2]))</span><br></pre></td></tr></table></figure>

<h4 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h4><p>给定两个字符串 s 和 t ，它们只包含小写字母。<br>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>请找出在 t 中被添加的字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(Counter(t) - Counter(s))[<span class="number">0</span>] </span><br></pre></td></tr></table></figure>

<h4 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h4><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。<br>示例:<br>输入: “Hello, my name is John”<br>输出: 5<br>解释: 这里的单词是指连续的不是空格的字符，所以 “Hello,” 算作 1 个单词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSegments</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.strip()</span><br><span class="line">        s_list = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)== <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">len</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> s_list <span class="keyword">if</span> <span class="built_in">len</span>(i)&gt;<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>


<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。<br>示例 1:<br>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findAnagrams(self, s: str, p: str) -&gt; List[int]:</span><br><span class="line">        output, hashmap, hashmap_p = [], &#123;&#125;, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        for char in p:</span><br><span class="line">            hashmap_p[char]=hashmap_p.get(char,0) + 1</span><br><span class="line"></span><br><span class="line">        start=0</span><br><span class="line">        for end in range(len(s)):</span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end], 0) + 1</span><br><span class="line">            if hashmap == hashmap_p:</span><br><span class="line">                output.append(start)</span><br><span class="line"></span><br><span class="line">            if end&gt;= len(p) -1:</span><br><span class="line">                hashmap[s[start]] -= 1</span><br><span class="line">                if hashmap[s[start]] == 0:</span><br><span class="line">                    del hashmap[s[start]]</span><br><span class="line">                start += 1</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>

<h4 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485.最大连续1的个数"></a>485.最大连续1的个数</h4><p>给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result,max_res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[end] ==<span class="number">1</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                max_res=<span class="built_in">max</span>(max_res, result)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure>


<h4 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h4><p>我们定义，在以下情况时，单词的大写用法是正确的：<br>全部字母都是大写，比如 “USA” 。<br>单词中所有字母都不是大写，比如 “leetcode” 。<br>如果单词不只含有一个字母，只有首字母大写， 比如 “Google” 。<br>给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCapitalUse</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span>  <span class="built_in">str</span>.isupper(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">str</span>.islower(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">str</span>.islower(word[<span class="number">1</span>:]) <span class="keyword">and</span> <span class="built_in">str</span>.isupper(word[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542.01 矩阵"></a>542.01 矩阵</h4><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateMatrix</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat <span class="keyword">and</span> mat[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">dir</span> = [(-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> mat[r][c] == <span class="number">0</span>:</span><br><span class="line">                    queue.append((r, c))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mat[r][c] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r, c = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dr,dc <span class="keyword">in</span> <span class="built_in">dir</span>:</span><br><span class="line">                nr, nc = r + dr, c + dc</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr &gt;= m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc &gt;= n <span class="keyword">or</span> mat[nr][nc] != -<span class="number">1</span>: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                mat[nr][nc] = mat[r][c] + <span class="number">1</span></span><br><span class="line">                queue.append((nr, nc))</span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>

<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。<br>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。<br>返回矩阵中 省份 的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:</span><br><span class="line">        def dfs(i: int):</span><br><span class="line">            for j in range(cities):</span><br><span class="line">                if isConnected[i][j] == 1 and j not in visited:</span><br><span class="line">                    visited.add(j)</span><br><span class="line">                    dfs(j)</span><br><span class="line"></span><br><span class="line">        cities = len(isConnected)</span><br><span class="line">        visited = set()</span><br><span class="line">        provinces = 0</span><br><span class="line"></span><br><span class="line">        for i in range(cities):</span><br><span class="line">            if i not in visited:</span><br><span class="line">                dfs(i)</span><br><span class="line">                provinces += 1</span><br><span class="line"></span><br><span class="line">        return provinces</span><br></pre></td></tr></table></figure>

<h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567.字符串的排列"></a>567.字符串的排列</h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hashmap1, hashmap2, result = &#123;&#125;, &#123;&#125;, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s1:</span><br><span class="line">            hashmap1[char] = hashmap1.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">            hashmap2[s2[end]] = hashmap2.get(s2[end], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap2 == hashmap1:</span><br><span class="line">                result = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(s1) - <span class="number">1</span>:</span><br><span class="line">                hashmap2[s2[start]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap2[s2[start]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap2[s2[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>


<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a>572.另一棵树的子树</h4><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。<br>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isSubtree(self, s, t):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: TreeNode</span><br><span class="line">        :type t: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not s and not t:</span><br><span class="line">            return True</span><br><span class="line">        if not s or not t:</span><br><span class="line">            return False</span><br><span class="line">        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)</span><br><span class="line"></span><br><span class="line">    def isSameTree(self, s, t):</span><br><span class="line">        if not s and not t:</span><br><span class="line">            return True</span><br><span class="line">        if not s or not t:</span><br><span class="line">            return False</span><br><span class="line">        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h4><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:        <span class="comment"># 如果 root1 为空，则合并之后节点为 root2</span></span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:        <span class="comment"># 如果 root2 为空，则合并之后节点为 root1</span></span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root = TreeNode(root1.val + root2.val)               <span class="comment"># 如果都存在节点，创建一个新的节点存储合并后的值</span></span><br><span class="line">        root.left = self.mergeTrees(root1.left, root2.left)  <span class="comment"># 递归合并左子树</span></span><br><span class="line">        root.right = self.mergeTrees(root1.right, root2.right)  <span class="comment"># 递归合并右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643.子数组最大平均数 I"></a>643.子数组最大平均数 I</h4><p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。<br>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。<br>任何误差小于 10-5 的答案都将被视为正确答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        sum_, max_avg = <span class="number">0</span>, -math.inf</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_avg = <span class="built_in">max</span>(max_avg, sum_ / k)</span><br><span class="line">            <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_avg</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h4><p>给你一个大小为 m x n 的二进制矩阵 grid 。<br>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>岛屿的面积是岛上值为 1 的单元格的数目。<br>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 遍历二维数组，对于每块土地，去其前后左右找相邻土地，再去前后左右的土地找其前后左右的土地，直到周围没有土地</span></span><br><span class="line"><span class="string">        对于每一块已找过的土地，为避免重复计算，将其置为0</span></span><br><span class="line"><span class="string">        其实就是遍历了所有的岛屿，然后取这些岛屿的最大面积res = max(res, dfs(i, j)) &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n <span class="keyword">and</span> grid[i][j]:</span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dfs(i - <span class="number">1</span>, j) + dfs(i + <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>) + dfs(i, j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dfs(i, j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713.乘积小于 K 的子数组"></a>713.乘积小于 K 的子数组</h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。<br>示例 1：<br>输入：nums = [10,5,2,6], k = 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        result, mutil = 0, 1    # Step 1: 定义需要维护的变量</span><br><span class="line">        start = 0                        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            mutil *= nums[end]           # Step 3: 更新需要维护的变量 (min_len, sum_)</span><br><span class="line">            while mutil &gt;= k and start &lt;= end:</span><br><span class="line">                mutil //= nums[start]    </span><br><span class="line">                start += 1</span><br><span class="line">            else:</span><br><span class="line">                result += end-start+1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733.图像渲染"></a>733.图像渲染</h4><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。<br>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。<br>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。<br>最后返回 经过上色渲染后的图像 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">floodFill</span>(<span class="params">self, image: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], sr: <span class="built_in">int</span>, sc: <span class="built_in">int</span>, newColor: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> newColor == image[sr][sc]:  <span class="comment"># 起始颜色和目标颜色相同，则直接返回原图</span></span><br><span class="line">            <span class="keyword">return</span> image</span><br><span class="line">        directions = &#123;(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)&#125;  <span class="comment"># 设置四个方向偏移量，一种常见的省事儿技巧</span></span><br><span class="line">        que = Queue()  <span class="comment"># 构造一个队列，先把起始点放进去</span></span><br><span class="line">        que.put((sr, sc))  <span class="comment"># 记录初始颜色</span></span><br><span class="line">        originalcolor = image[sr][sc]  <span class="comment"># 当队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> que.empty():  <span class="comment"># 取出队列的点并染色</span></span><br><span class="line">            point = que.get()</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor  <span class="comment"># 遍历四个方向</span></span><br><span class="line">            <span class="keyword">for</span> direction <span class="keyword">in</span> directions:  <span class="comment"># 新点是(new_i,new_j)</span></span><br><span class="line">                new_i = point[<span class="number">0</span>] + direction[<span class="number">0</span>]</span><br><span class="line">                new_j = point[<span class="number">1</span>] + direction[<span class="number">1</span>]  <span class="comment"># 如果这个点在定义域内并且它和原来的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= new_i &lt; <span class="built_in">len</span>(image) <span class="keyword">and</span> <span class="number">0</span> &lt;= new_j &lt; <span class="built_in">len</span>(image[<span class="number">0</span>]) <span class="keyword">and</span> image[new_i][new_j] == originalcolor:</span><br><span class="line">                    que.put((new_i, new_j))</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>


<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h4><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:</span><br><span class="line">        stack, res = [], [0]* len(temperatures)</span><br><span class="line">        for i , num in enumerate(temperatures):</span><br><span class="line">            while stack and temperatures[stack[-1]]&lt; num:</span><br><span class="line">                index = stack.pop()</span><br><span class="line">                res[index] = i - index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="784-字母大小全排列"><a href="#784-字母大小全排列" class="headerlink" title="784.字母大小全排列"></a>784.字母大小全排列</h4><p>给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。<br>返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCasePermutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isalpha():</span><br><span class="line">                ans = [a + c.lower() <span class="keyword">for</span> a <span class="keyword">in</span> ans] + [a + c.upper() <span class="keyword">for</span> a <span class="keyword">in</span> ans]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = [a + c <span class="keyword">for</span> a <span class="keyword">in</span> ans]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796.旋转字符串"></a>796.旋转字符串</h4><p>给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。<br>s 的 旋转操作 就是将 s 最左边的字符移动到最右边。<br>例如, 若 s = ‘abcde’，在旋转一次之后结果就是’bcdea’ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateString</span>(<span class="params">self, s: <span class="built_in">str</span>, goal: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= length:</span><br><span class="line">            s = s[<span class="number">1</span>:]+s[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> s == goal:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a>844. 比较含退格的字符串</h4><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。<br>注意：如果对空文本输入退格字符，文本继续为空。<br>示例 1：<br>输入：s = “ab#c”, t = “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def backspaceCompare(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        def remove_(str_):</span><br><span class="line">            r = []</span><br><span class="line">            for i in range(len(str_)):</span><br><span class="line">                if str_[i] != &#x27;#&#x27;:</span><br><span class="line">                    r.append(str_[i])</span><br><span class="line">                elif str_[i] == &#x27;#&#x27; and len(r)&gt;=1:</span><br><span class="line">                    r.pop()</span><br><span class="line"></span><br><span class="line">            return r</span><br><span class="line"></span><br><span class="line">        return remove_(s) ==remove_(t)</span><br></pre></td></tr></table></figure>

<h4 id="944-腐烂的橘子"><a href="#944-腐烂的橘子" class="headerlink" title="944.腐烂的橘子"></a>944.腐烂的橘子</h4><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">orangesRotting</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        row = <span class="built_in">len</span>(grid)</span><br><span class="line">        col = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        rotten = &#123;(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col) <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>&#125; <span class="comment"># 腐烂集合</span></span><br><span class="line">        fresh = &#123;(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col) <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>&#125;  <span class="comment"># 新鲜集合</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fresh:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rotten: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 即将腐烂的如果在新鲜的集合中，就将它腐烂</span></span><br><span class="line">            rotten = &#123;(i + di, j + dj) <span class="keyword">for</span> i, j <span class="keyword">in</span> rotten <span class="keyword">for</span> di, dj <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)] <span class="keyword">if</span> (i + di, j + dj) <span class="keyword">in</span> fresh&#125; </span><br><span class="line">            fresh -= rotten <span class="comment"># 剔除腐烂的</span></span><br><span class="line">            time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> time</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986.区间列表的交集"></a>986.区间列表的交集</h4><p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。<br>返回这 两个区间列表的交集 。<br>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。<br>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。<br><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png"><br>输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]<br>输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        res=[]</span><br><span class="line">        n,m=len(firstList),len(secondList)</span><br><span class="line">        i,j=0,0</span><br><span class="line">        while i&lt;n and j&lt;m:</span><br><span class="line">            left = max(firstList[i][0],secondList[j][0])</span><br><span class="line">            right = min(firstList[i][1],secondList[j][1])</span><br><span class="line">            if left &lt;= right:                         #判断是否有交集的条件</span><br><span class="line">                res.append([left,right])</span><br><span class="line">            if firstList[i][1]&lt;secondList[j][1]:    #哪个右区间元素较小，指针就向前移动一位</span><br><span class="line">                i+=1</span><br><span class="line">            else:e</span><br><span class="line">                j+=1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="1695-删除子数组的最大得分"><a href="#1695-删除子数组的最大得分" class="headerlink" title="1695.删除子数组的最大得分"></a>1695.删除子数组的最大得分</h4><p>给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。<br>返回 只删除一个 子数组可获得的 最大得分 。<br>如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumUniqueSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        sum_,max_sum, hashmap=0, 0, &#123;&#125;</span><br><span class="line">        start = 0</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            hashmap[nums[end]] = hashmap.get(nums[end], 0) + 1</span><br><span class="line">            if hashmap.get(nums[end], 0) &lt; 2:</span><br><span class="line">                max_sum = max(max_sum, sum_)</span><br><span class="line">            while hashmap[nums[end]]&gt;=2:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                sum_ -= head</span><br><span class="line">                hashmap[head] -= 1</span><br><span class="line">                if hashmap[head] ==0:</span><br><span class="line">                    del hashmap[head]</span><br><span class="line">                start += 1</span><br><span class="line">        return max_sum</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="/js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://easylink.cc/e53y50',
  alipayImage: 'https://easylink.cc/fmyobu'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Bai Xiong</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2023/01/01/DataStructures&algorithms/" target="_blank" title="数据结构和算法题 Data Structures&amp; Algorothms">http://example.com/2023/01/01/DataStructures&algorithms/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataStructures-Algorothms/" rel="tag">DataStructures&Algorothms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/01/01/DataStructures&algorithms1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构和算法基础概念 Data Structures&amp; Algorothms
        
      </div>
    </a>
  
  
    <a href="/2022/12/31/DataMining/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据挖掘 DataMining</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode%E9%A2%98%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">leetcode题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text">3.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">11.盛最多水的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.3.</span> <span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.4.</span> <span class="nav-text">20.有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">21.合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E6%95%88%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">1.6.</span> <span class="nav-text">26.删除有效数组中的重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.</span> <span class="nav-text">33.搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.8.</span> <span class="nav-text">34.在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">1.9.</span> <span class="nav-text">46.全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="nav-number">1.10.</span> <span class="nav-text">67.二进制求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">1.11.</span> <span class="nav-text">70.爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-number">1.12.</span> <span class="nav-text">74.搜索二维矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">1.13.</span> <span class="nav-text">77.组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.14.</span> <span class="nav-text">82.删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.15.</span> <span class="nav-text">83.删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.16.</span> <span class="nav-text">88.合并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">1.17.</span> <span class="nav-text">100.相同的树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.18.</span> <span class="nav-text">111.二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">1.19.</span> <span class="nav-text">116.填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="nav-number">1.20.</span> <span class="nav-text">117.填充每个节点的下一个右侧节点指针 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">1.21.</span> <span class="nav-text">120.三角形最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="nav-number">1.22.</span> <span class="nav-text">136.只出现一次的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">1.23.</span> <span class="nav-text">153.寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">1.24.</span> <span class="nav-text">162.寻找峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="nav-number">1.25.</span> <span class="nav-text">190.颠倒二进制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.26.</span> <span class="nav-text">191.位1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">1.27.</span> <span class="nav-text">198.打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">1.28.</span> <span class="nav-text">200.岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.29.</span> <span class="nav-text">205.同构字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.30.</span> <span class="nav-text">206.反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.31.</span> <span class="nav-text">209.长度最小的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#231-2%E7%9A%84%E5%B9%82"><span class="nav-number">1.32.</span> <span class="nav-text">231.2的幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#263-%E4%B8%91%E6%95%B0"><span class="nav-number">1.33.</span> <span class="nav-text">263.丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">1.34.</span> <span class="nav-text">349.两个数组的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C"><span class="nav-number">1.35.</span> <span class="nav-text">389.找不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="nav-number">1.36.</span> <span class="nav-text">434.字符串中的单词数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">1.37.</span> <span class="nav-text">438.找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.38.</span> <span class="nav-text">485.最大连续1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#520-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D"><span class="nav-number">1.39.</span> <span class="nav-text">520.检测大写字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#542-01-%E7%9F%A9%E9%98%B5"><span class="nav-number">1.40.</span> <span class="nav-text">542.01 矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="nav-number">1.41.</span> <span class="nav-text">547.省份数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">1.42.</span> <span class="nav-text">567.字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number">1.43.</span> <span class="nav-text">572.另一棵树的子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.44.</span> <span class="nav-text">617.合并二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I"><span class="nav-number">1.45.</span> <span class="nav-text">643.子数组最大平均数 I</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">1.46.</span> <span class="nav-text">695.岛屿的最大面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.47.</span> <span class="nav-text">713.乘积小于 K 的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="nav-number">1.48.</span> <span class="nav-text">733.图像渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">1.49.</span> <span class="nav-text">739.每日温度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">1.50.</span> <span class="nav-text">784.字母大小全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#796-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.51.</span> <span class="nav-text">796.旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.52.</span> <span class="nav-text">844. 比较含退格的字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#944-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">1.53.</span> <span class="nav-text">944.腐烂的橘子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">1.54.</span> <span class="nav-text">986.区间列表的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="nav-number">1.55.</span> <span class="nav-text">1695.删除子数组的最大得分</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2023 HELLO WORLD All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/collection" class="mobile-nav-link">Collection</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>









	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            HELLO WORLD
          </div>
          <div class="panel-body">
            Copyright © 2023 Bai Xiong All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>

  <!--单击显示文字-->
  <script type="text/javascript" src="/js/click_show_text.js"></script>

  <!--动态线条背景-->
  <script type="text/javascript"
  color="220,220,220" opacity='0.5' zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
  </script>

  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
