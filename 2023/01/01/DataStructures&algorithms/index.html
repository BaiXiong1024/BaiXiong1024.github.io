<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构和算法题 data structures&amp; algorothms | HELLO WORLD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="PythonDataStructures&Algorothms" />
  
  
  
  
  <meta name="description" content="leetcode刷题记录 – 持续更新中">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法题 Data Structures&amp; Algorothms">
<meta property="og:url" content="http://example.com/2023/01/01/DataStructures&algorithms/index.html">
<meta property="og:site_name" content="HELLO WORLD">
<meta property="og:description" content="leetcode刷题记录 – 持续更新中">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
<meta property="article:published_time" content="2023-01-01T02:10:12.000Z">
<meta property="article:modified_time" content="2024-02-27T09:05:03.317Z">
<meta property="article:author" content="Bai Xiong">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="DataStructures&amp;Algorothms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
  
    <link rel="alternate" href="/atom.xml" title="HELLO WORLD" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt; src:url("/css/fonts/FuturaPTBold.otf") format("woff");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt-light; src:url("/css/fonts/FuturaPTBook.otf") format("woff");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt-italic; src:url("/css/fonts/FuturaPTBookOblique.otf") format("woff");font-weight:400;font-style:italic;}
}

  </style>
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>

  
<script src="/js/bootstrap.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    
<link rel="stylesheet" href="/css/dialog.css">

  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

<meta name="generator" content="Hexo 5.4.2"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">Home</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">Archives</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">Categories</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">Tags</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">About</a> </li>
                
                  <li> <a class="main-nav-link" href="/collection">collection</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      

      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-DataStructures&amp;algorithms" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      数据结构和算法题 Data Structures&amp; Algorothms
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2023/01/01/DataStructures&algorithms/" class="article-date">
	  <time datetime="2023-01-01T02:10:12.000Z" itemprop="datePublished">2023-01-01</time>
	</a>

      
    <a class="article-category-link" href="/categories/Code/">Code</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		PV:<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

      

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>leetcode刷题记录 – 持续更新中</p>
<span id="more"></span>


<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 可以按任意顺序返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            temp=nums[:i]</span><br><span class="line">            <span class="built_in">print</span>(i, temp,nums[i], target-nums[i])</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] <span class="keyword">in</span> temp:</span><br><span class="line">                j = temp.index(target-nums[i])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [j, i]</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_len, hashmap=<span class="number">0</span>,&#123;&#125;</span><br><span class="line">        start =<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hashmap) == end-start +<span class="number">1</span>:</span><br><span class="line">                max_len = <span class="built_in">max</span>(max_len, end-start+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> end-start+<span class="number">1</span> &gt;<span class="built_in">len</span>(hashmap):</span><br><span class="line">                hashmap[s[start]] -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[s[start]]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap[s[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h4><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        i, j, res = 0, len(height)-1, 0</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            if height[i]&lt;=height[j]:</span><br><span class="line">                res = max(res, height[i]*(j-i))</span><br><span class="line">                i += 1</span><br><span class="line">            elif height[i]&gt;height[j]:</span><br><span class="line">                res = max(res, height[j]*(j-i))</span><br><span class="line">                j -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        strs_dict = &#123;&#125;</span><br><span class="line">        length = []</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> str_ <span class="keyword">in</span>  strs:</span><br><span class="line">            strs_dict[str_] = <span class="built_in">list</span>(str_)</span><br><span class="line">            length.append(<span class="built_in">len</span>(<span class="built_in">list</span>(str_)))</span><br><span class="line">        min_length = <span class="built_in">min</span>(length)</span><br><span class="line">        lengths=<span class="number">0</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">while</span> lengths &lt; min_length <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(temp))&lt;=<span class="number">1</span>:</span><br><span class="line">            temp=[]</span><br><span class="line">            <span class="keyword">for</span> keys <span class="keyword">in</span> strs_dict:</span><br><span class="line">                temp.append(strs_dict[keys][lengths])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(temp))==<span class="number">1</span>:</span><br><span class="line">                output.append(temp[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            lengths+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(output)</span><br></pre></td></tr></table></figure>


<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h4><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请<br>你返回所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res, k = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment"># 1. because of j &gt; i &gt; k.</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> nums[k] == nums[k - <span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment"># 2. skip the same `nums[k]`.</span></span><br><span class="line">            i, j = k + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j: <span class="comment"># 3. double pointer</span></span><br><span class="line">                s = nums[k] + nums[i] + nums[j]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[k], nums[i], nums[j]])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] == nums[j + <span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="17-电话号码的数字组合"><a href="#17-电话号码的数字组合" class="headerlink" title="17.电话号码的数字组合"></a>17.电话号码的数字组合</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dic = &#123;<span class="string">&#x27;2&#x27;</span> :<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;3&#x27;</span> :<span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;4&#x27;</span> :<span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;5&#x27;</span> :<span class="string">&#x27;jkl&#x27;</span>, <span class="string">&#x27;6&#x27;</span> :<span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;7&#x27;</span> :<span class="string">&#x27;pqrs&#x27;</span> ,<span class="string">&#x27;8&#x27;</span> :<span class="string">&#x27;tuv&#x27;</span> ,<span class="string">&#x27;9&#x27;</span> :<span class="string">&#x27;wxyz&#x27;</span>&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == n:</span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(tmp))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> dic[digits[index]]:</span><br><span class="line">                    tmp.append(i)</span><br><span class="line">                    dfs(index + <span class="number">1</span>)</span><br><span class="line">                    tmp.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        tmp = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.删除链表的倒数第N个节点</h4><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment">#双指针 fast指向删除节点，slow指向删除节点的上一个节点</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        fast = dummy_head</span><br><span class="line">        slow = dummy_head</span><br><span class="line">        <span class="keyword">while</span> n != -<span class="number">1</span>:   <span class="comment">#先让fast节点前进n步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast != <span class="literal">None</span>:<span class="comment">#再让fast slow一起前进，这样slow最终指向被删节点的前一个节点</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># dic = &#123;&#x27;&#123;&#x27;:&#x27;&#125;&#x27;,&#x27;[&#x27;:&#x27;]&#x27;,&#x27;(&#x27;:&#x27;)&#x27;&#125;</span></span><br><span class="line">        dic = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] == dic[i]: stack.pop()</span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def isValid(self, s: str) -&gt; bool:</span></span><br><span class="line"><span class="comment">#         dic = &#123;&#x27;)&#x27;:&#x27;(&#x27;,&#x27;]&#x27;:&#x27;[&#x27;,&#x27;&#125;&#x27;:&#x27;&#123;&#x27;&#125;</span></span><br><span class="line"><span class="comment">#         stack = []</span></span><br><span class="line"><span class="comment">#         for i in s:</span></span><br><span class="line"><span class="comment">#             if stack and i in dic:</span></span><br><span class="line"><span class="comment">#                 if stack[-1] == dic[i]: stack.pop()</span></span><br><span class="line"><span class="comment">#                 else: return False</span></span><br><span class="line"><span class="comment">#             else: stack.append(i)</span></span><br><span class="line"><span class="comment">#         return not stack</span></span><br></pre></td></tr></table></figure>
<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>,l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1,l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="26-删除有效数组中的重复项"><a href="#26-删除有效数组中的重复项" class="headerlink" title="26.删除有效数组中的重复项"></a>26.删除有效数组中的重复项</h4><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。<br>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：<br>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。<br>判题标准:<br>系统会用下面的代码来测试你的题解:<br>int[] nums = […]; // 输入数组<br>int[] expectedNums = […]; // 长度正确的期望答案<br>int k = removeDuplicates(nums); // 调用<br>assert k == expectedNums.length;<br>for (int i = 0; i &lt; k; i++) {<br>    assert nums[i] == expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[slow]:</span><br><span class="line">                slow = slow + <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast = fast + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = nums.count(val)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>


<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def search(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        min_index = nums.index(min(nums))</span><br><span class="line">        nums_ = nums[min_index:]+nums[:min_index]</span><br><span class="line"></span><br><span class="line">        low = 0</span><br><span class="line">        high = len(nums_)-1</span><br><span class="line">        while low &lt;= high:</span><br><span class="line">            mid = (low + high)</span><br><span class="line">            guess = nums_[mid]</span><br><span class="line">            if guess == target:</span><br><span class="line">                return nums.index(nums_[mid])</span><br><span class="line">            if guess &gt; target:</span><br><span class="line">                high = mid - 1</span><br><span class="line">            else:</span><br><span class="line">                low = mid + 1</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h4><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binarySearchLeft</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;<span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            l = -<span class="number">1</span></span><br><span class="line">            r = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> l+<span class="number">1</span> != r :</span><br><span class="line">                mid = l+(r-l)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target :</span><br><span class="line">                    r = mid</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    l = mid</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binarySearchRight</span>(<span class="params">nums:<span class="type">List</span>[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;<span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">            l = -<span class="number">1</span></span><br><span class="line">            r = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> l+<span class="number">1</span> != r :</span><br><span class="line">                mid = l+(r-l)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target :</span><br><span class="line">                    l = mid</span><br><span class="line">                <span class="keyword">else</span> :</span><br><span class="line">                    r = mid</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">        leftIdx = binarySearchLeft(nums, target)</span><br><span class="line">        rightIdx = binarySearchRight(nums, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftIdx&lt;=rightIdx <span class="keyword">and</span> rightIdx&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[leftIdx]==target <span class="keyword">and</span> nums[rightIdx]==target :</span><br><span class="line">            <span class="keyword">return</span> [leftIdx, rightIdx]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36.有效的数独"></a>36.有效的数独</h4><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        row, col, sqrt = defaultdict(<span class="built_in">set</span>), defaultdict(<span class="built_in">set</span>), defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                val = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> val == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                point = i // <span class="number">3</span> * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="built_in">print</span>(point)</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> row[i] <span class="keyword">or</span> val <span class="keyword">in</span> col[j] <span class="keyword">or</span> val <span class="keyword">in</span> sqrt[point]:</span><br><span class="line">                    <span class="built_in">print</span>(i, j, val)</span><br><span class="line">                    <span class="built_in">print</span>(row, col, sqrt)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                row[i].add(val)</span><br><span class="line">                col[j].add(val)</span><br><span class="line">                sqrt[point].add(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h4><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res, path, used = [], [], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line">                dfs()</span><br><span class="line">                <span class="comment"># 回溯的过程中，将当前的节点从 path 中删除</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h4><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>子数组 是数组中的一个连续部分。</p>
<h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h4><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。<br>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.strip(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        word_list = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        last_word = word_list.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(last_word)</span><br></pre></td></tr></table></figure>

<h4 id="61-加一"><a href="#61-加一" class="headerlink" title="61.加一"></a>61.加一</h4><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">int</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(num) <span class="keyword">for</span> num <span class="keyword">in</span> digits))+<span class="number">1</span>))]</span><br></pre></td></tr></table></figure>

<h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67.二进制求和"></a>67.二进制求和</h4><p>给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        return bin(int(a,2)+int(b,2))[2:]</span><br></pre></td></tr></table></figure>

<h4 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h4><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。<br>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。<br>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        x_2 = x // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x_2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i * i == x:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">elif</span> i * i &gt; x:</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x_2</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &lt; n:</span><br><span class="line">            <span class="built_in">print</span>(s)</span><br><span class="line">            s.append(s[-<span class="number">1</span>] + s[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> s[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73.矩阵置零"></a>73.矩阵置零</h4><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setZeroes</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row = <span class="built_in">len</span>(matrix)</span><br><span class="line">        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row_zero = <span class="built_in">set</span>()</span><br><span class="line">        col_zero = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    row_zero.add(i)</span><br><span class="line">                    col_zero.add(j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> row_zero <span class="keyword">or</span> j <span class="keyword">in</span> col_zero:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h4><p>给你一个满足下述两条属性的 m x n 整数矩阵：<br>每行中的整数从左到右按非递减顺序排列。<br>每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> list_ <span class="keyword">in</span> matrix:</span><br><span class="line">            nums += list_</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = (low + high)</span><br><span class="line">            guess = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> guess == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> guess &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h4><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">tmp: <span class="built_in">list</span>, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == k:</span><br><span class="line">                ans.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n + <span class="number">1</span>):</span><br><span class="line">                tmp.append(i)</span><br><span class="line">                backtrack(tmp, i + <span class="number">1</span>)</span><br><span class="line">                tmp.pop()</span><br><span class="line">        backtrack([], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


<h4 id="82-删除排序链表中的重复元素"><a href="#82-删除排序链表中的重复元素" class="headerlink" title="82.删除排序链表中的重复元素"></a>82.删除排序链表中的重复元素</h4><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val != head.<span class="built_in">next</span>.val:</span><br><span class="line">            head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            move = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> move <span class="keyword">and</span> head.val == move.val:</span><br><span class="line">                move = move.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(move)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a>83.删除排序链表中的重复元素</h4><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur =cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span></span><br><span class="line"><span class="comment">#         if head is None:</span></span><br><span class="line"><span class="comment">#             return None</span></span><br><span class="line"><span class="comment">#         cur = head</span></span><br><span class="line"><span class="comment">#         while cur.next:</span></span><br><span class="line"><span class="comment">#             if cur.next.val == cur.val:</span></span><br><span class="line"><span class="comment">#                 cur.next = cur.next.next</span></span><br><span class="line"><span class="comment">#             else:</span></span><br><span class="line"><span class="comment">#                 cur = cur.next</span></span><br><span class="line"><span class="comment">#         return head</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h4><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums1[:] = sorted(nums1[:m]+nums2)</span><br><span class="line">        # nums1[:] = sorted(nums1[:m] + nums2)</span><br></pre></td></tr></table></figure>

<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h4><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="111-二叉树的最大深度"><a href="#111-二叉树的最大深度" class="headerlink" title="111.二叉树的最大深度"></a>111.二叉树的最大深度</h4><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">min_tree_depth</span>(<span class="params">r</span>):</span><br><span class="line">            <span class="keyword">if</span> r == <span class="literal">None</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = min_tree_depth(r.left)</span><br><span class="line">            right = min_tree_depth(r.right)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(l, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_tree_depth(root)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h4><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:</span><br><span class="line">        if root == None:</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        def BFS(oneLayer):</span><br><span class="line">            nextLayer = []   # 每一次都搞个空的列表，去建立nextLayer</span><br><span class="line">            for i in oneLayer:</span><br><span class="line">                if i.left:</span><br><span class="line">                    nextLayer.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    nextLayer.append(i.right)</span><br><span class="line"></span><br><span class="line">            if len(nextLayer) &gt; 1:  # 一共只有1个节点就没必要搞了。</span><br><span class="line">                for j in range(0, len(nextLayer) - 1):</span><br><span class="line">                    nextLayer[j].next = nextLayer[j + 1]  # 每个节点的next指向后面一个节点。</span><br><span class="line"></span><br><span class="line">            if nextLayer:  # nextLayer不是空的话就继续往下走。</span><br><span class="line">                BFS(nextLayer)</span><br><span class="line"></span><br><span class="line">        BFS([root])  # 最开始就是只有一层一个根节点。</span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针 II"></a>117.填充每个节点的下一个右侧节点指针 II</h4><p>给定一个二叉树：<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。<br>初始状态下，所有 next 指针都被设置为 NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;:</span><br><span class="line">        if root == None:</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        def BFS(oneLayer):</span><br><span class="line">            nextLayer = []   # 每一次都搞个空的列表，去建立nextLayer</span><br><span class="line">            for i in oneLayer:</span><br><span class="line">                if i.left:</span><br><span class="line">                    nextLayer.append(i.left)</span><br><span class="line">                if i.right:</span><br><span class="line">                    nextLayer.append(i.right)</span><br><span class="line"></span><br><span class="line">            if len(nextLayer) &gt; 1:  # 一共只有1个节点就没必要搞了。</span><br><span class="line">                for j in range(0, len(nextLayer) - 1):</span><br><span class="line">                    nextLayer[j].next = nextLayer[j + 1]  # 每个节点的next指向后面一个节点。</span><br><span class="line"></span><br><span class="line">            if nextLayer:  # nextLayer不是空的话就继续往下走。</span><br><span class="line">                BFS(nextLayer)</span><br><span class="line"></span><br><span class="line">        BFS([root])  # 最开始就是只有一层一个根节点。</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>
<h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h4><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [[<span class="number">1</span>]*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, numRows+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> index, element <span class="keyword">in</span> <span class="built_in">enumerate</span>(res):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(element)-<span class="number">1</span>):</span><br><span class="line">                element[j] = res[index-<span class="number">1</span>][j-<span class="number">1</span>] + res[index-<span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120.三角形最小路径和"></a>120.三角形最小路径和</h4><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。<br>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i])):</span><br><span class="line">                triangle[i][j] = triangle[i][j] + <span class="built_in">min</span>(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;前i天的最大收益等于 max(前i-1天最大收益,第i天价格-前i天最小价格)&#x27;&#x27;&#x27;</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        minprice = <span class="number">1e9</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            minprice = <span class="built_in">min</span>(minprice, prices[i])</span><br><span class="line">            profit = <span class="built_in">max</span>(profit,prices[i]-minprice)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>


<h4 id="136-只出现一次的数"><a href="#136-只出现一次的数" class="headerlink" title="136.只出现一次的数"></a>136.只出现一次的数</h4><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            n = nums.count(i)</span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h4><p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h4><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改 链表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head</span>):</span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (fast <span class="keyword">and</span> fast.<span class="built_in">next</span>): <span class="keyword">return</span> </span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow: </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>


<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.寻找旋转排序数组中的最小值</h4><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums)</span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>自定义评测：<br>评测系统 的输入如下（你设计的程序 不适用 此输入）：<br>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        nodeA = headA</span><br><span class="line">        nodeB = headB</span><br><span class="line">        <span class="keyword">while</span> (nodeA != nodeB):</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span> <span class="keyword">if</span> nodeA <span class="keyword">else</span> headB</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span> <span class="keyword">if</span> nodeB <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>



<h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162.寻找峰值"></a>162.寻找峰值</h4><p>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> nums.index(<span class="built_in">max</span>(nums))</span><br></pre></td></tr></table></figure>

<h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h4><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count_dict=&#123;&#125;</span><br><span class="line">        <span class="comment"># length = len(nums)//2</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums)):</span><br><span class="line">            count_dict[num] = nums.count(num)</span><br><span class="line">        <span class="comment"># res = [k for k, v in count_dict.items() if v &gt;= length]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(count_dict, key=<span class="keyword">lambda</span> x: count_dict[x])</span><br></pre></td></tr></table></figure>


<h4 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175.组合两个表"></a>175.组合两个表</h4><p>表: Person<br>+————-+———+<br>| 列名         | 类型     |<br>+————-+———+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br>+————-+———+<br>personId 是该表的主键（具有唯一值的列）。<br>该表包含一些人的 ID 和他们的姓和名的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select  firstName ,lastName ,city ,state</span><br><span class="line">from Person t1 left join Address t2 on t1.PersonId=t2.PersonId    </span><br></pre></td></tr></table></figure>


<h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176.第二高的薪水"></a>176.第二高的薪水</h4><p>Employee 表：<br>+————-+——+<br>| Column Name | Type |<br>+————-+——+<br>| id          | int  |<br>| salary      | int  |<br>+————-+——+<br>在 SQL 中，id 是这个表的主键。<br>表的每一行包含员工的工资信息。<br>查询并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null(Pandas 则返回 None) 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> (</span><br><span class="line">    <span class="keyword">select</span> salary <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> salary, <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) rn </span><br><span class="line">        <span class="keyword">from</span> Employee</span><br><span class="line">        ) t <span class="keyword">where</span> t.rn<span class="operator">=</span><span class="number">2</span> limit <span class="number">1</span></span><br><span class="line">        ) SecondHighestSalary;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190.颠倒二进制位"></a>190.颠倒二进制位</h4><p>颠倒给定的 32 位无符号整数的二进制位。<br>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        bits = <span class="built_in">bin</span>(n)[<span class="number">2</span>:][::-<span class="number">1</span>]</span><br><span class="line">        bits += <span class="string">&quot;0&quot;</span>*(<span class="number">32</span>-<span class="built_in">len</span>(bits))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(bits, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。<br>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&quot;1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="193-有效电话号码"><a href="#193-有效电话号码" class="headerlink" title="193.有效电话号码"></a>193.有效电话号码</h4><p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。<br>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）<br>你也可以假设每行前后没有多余的空格字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read from the file file.txt and output all valid phone numbers to stdout.</span></span><br><span class="line">python3 -c <span class="string">&quot;import re;lines=open(&#x27;file.txt&#x27;).readlines();lines=[i.strip()for i in lines];ans=[i for i in lines if re.match(&#x27;^\(\d&#123;3&#125;\) \d&#123;3&#125;-\d&#123;4&#125;$&#x27;,i) or re.match(&#x27;^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$&#x27;,i)];   print(&#x27;\n&#x27;.join(ans))&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196.删除重复的电子邮箱"></a>196.删除重复的电子邮箱</h4><p>表: Person<br>+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| id          | int     |<br>| email       | varchar |<br>+————-+———+<br>id 是该表的主键列(具有唯一值的列)。<br>该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。<br>编写解决方案 删除 所有重复的电子邮件，只保留一个具有最小 id 的唯一电子邮件。<br>（对于 SQL 用户，请注意你应该编写一个 DELETE 语句而不是 SELECT 语句。）<br>（对于 Pandas 用户，请注意你应该直接修改 Person 表。）<br>运行脚本后，显示的答案是 Person 表。驱动程序将首先编译并运行您的代码片段，然后再显示 Person 表。Person 表的最终顺序 无关紧要 。<br>返回结果格式如下示例所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Please write a DELETE statement and DO NOT write a SELECT statement.</span><br><span class="line"># Write your MySQL query statement below</span><br><span class="line">DELETE p1 FROM Person p1,</span><br><span class="line">    Person p2</span><br><span class="line">WHERE</span><br><span class="line">    p1.Email = p2.Email AND p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>


<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每次循环，计算“偷到当前房子为止的最大金额”</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]</span></span><br><span class="line">            <span class="comment"># dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;</span></span><br><span class="line">            prev, curr = curr, <span class="built_in">max</span>(curr, prev + i)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]</span></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>


<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。<br>示例 1：<br>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：<br>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numIslands(self, grid: List[List[str]]) -&gt; int:</span><br><span class="line">        def dfs(grid,r,c):</span><br><span class="line">            if not 0&lt;=r&lt;len(grid) or not 0&lt;=c&lt;len(grid[0]):return</span><br><span class="line">            if grid[r][c]!=&quot;1&quot;:return  #注意题目这里输入的是字符&quot;0&quot;,“1”</span><br><span class="line">            grid[r][c]=&quot;2&quot;</span><br><span class="line">            dfs(grid,r-1,c)</span><br><span class="line">            dfs(grid,r+1,c)</span><br><span class="line">            dfs(grid,r,c-1)</span><br><span class="line">            dfs(grid,r,c+1)</span><br><span class="line">            return 1  #是岛屿,则返回1</span><br><span class="line"></span><br><span class="line">        res=0</span><br><span class="line">        for  r in range(len(grid)):</span><br><span class="line">            for c in range(len(grid[0])):</span><br><span class="line">                if grid[r][c]==&quot;1&quot;:</span><br><span class="line">                    res+=dfs(grid,r,c)  #累加岛屿的数量</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h4><p>给定两个字符串 s 和 t ，判断它们是否是同构的。<br>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return all(s.index(s[i]) == t.index(t[i])  for i in range(len(s)))</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): </span><br><span class="line">            <span class="keyword">if</span> s.index(s[i]) == t.index(t[i]): </span><br><span class="line">                <span class="keyword">continue</span> </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        </span></span><br><span class="line">    <span class="comment">#     prev, curr = None, head</span></span><br><span class="line">    <span class="comment">#     while curr is not None:</span></span><br><span class="line">    <span class="comment">#         next = curr.next</span></span><br><span class="line">    <span class="comment">#         curr.next = prev</span></span><br><span class="line">    <span class="comment">#         prev = curr</span></span><br><span class="line">    <span class="comment">#         curr = next</span></span><br><span class="line">    <span class="comment">#     return prev</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。<br>示例 1：<br>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:</span><br><span class="line">        min_len, sum_ = math.inf, 0    # Step 1: 定义需要维护的变量, 本题求最小长度，所以需要定义min_len, 本题又涉及求和，因此还需要一个sum变量</span><br><span class="line">        start = 0   # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            sum_ += nums[end]   # Step 3: 更新需要维护的变量 (min_len, sum_)</span><br><span class="line">            while sum_ &gt;= target:    # Step 4 这一题这里稍微有一点特别: sum_ &gt;= target其实是合法的，但由于我们要求的是最小长度，</span><br><span class="line">                min_len = min(min_len, end - start + 1)</span><br><span class="line">                sum_ -= nums[start]    </span><br><span class="line">                # 所以当sum_已经大于target的时候继续移动右指针没有意义，因此还是需要移动左指针慢慢逼近答案</span><br><span class="line">                # 由于左指针的移动可能影响min_len和sum_的值，因此需要在移动前将它们更新</span><br><span class="line">                start += 1</span><br><span class="line">        if min_len == math.inf:   # Step 5：返回答案 (最小长度)</span><br><span class="line">            return 0</span><br><span class="line">        return min_len</span><br></pre></td></tr></table></figure>

<h4 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h4><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        len1 = <span class="built_in">len</span>(nums)</span><br><span class="line">        len2 = <span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(nums)))</span><br><span class="line">        <span class="keyword">if</span> len1 != len2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="219-存在重复的元素II"><a href="#219-存在重复的元素II" class="headerlink" title="219.存在重复的元素II"></a>219.存在重复的元素II</h4><p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k 。如果存在，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:</span><br><span class="line">        list_dict = &#123;&#125;</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i] not in list_dict:</span><br><span class="line">                list_dict[nums[i]]=i</span><br><span class="line">            else:</span><br><span class="line">                if i- list_dict[nums[i]] &lt;=k:</span><br><span class="line">                    return True</span><br><span class="line">                else :</span><br><span class="line">                    list_dict[nums[i]] = i</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>


<h4 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231.2的幂"></a>231.2的幂</h4><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。<br>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258.各位相加"></a>258.各位相加</h4><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addDigits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(<span class="built_in">str</span>(num)) &gt;= <span class="number">2</span>:</span><br><span class="line">            num = <span class="built_in">sum</span>(<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">str</span>(num)))</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263.丑数"></a>263.丑数</h4><p>丑数 就是只包含质因数 2、3 和 5 的正整数。<br>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isUgly(self, n: int) -&gt; bool:</span><br><span class="line">        if n &lt;=0:</span><br><span class="line">            return False</span><br><span class="line">        while n % 2 == 0 :</span><br><span class="line">            n //= 2</span><br><span class="line">        while n % 3 == 0 :</span><br><span class="line">            n //= 3</span><br><span class="line">        while n % 5 == 0 :</span><br><span class="line">            n //= 5</span><br><span class="line">        return n ==1</span><br></pre></td></tr></table></figure>

<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h4><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> nums1 <span class="keyword">if</span> i <span class="keyword">in</span> nums2]))</span><br></pre></td></tr></table></figure>

<h4 id="350-两个数组的交集II"><a href="#350-两个数组的交集II" class="headerlink" title="350.两个数组的交集II"></a>350.两个数组的交集II</h4><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致<br>（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        jiaoji = <span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> jiaoji:</span><br><span class="line">            res += [i] * <span class="built_in">min</span>(nums1.count(i), nums2.count(i))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382.链表随机节点"></a>382.链表随机节点</h4><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。<br>实现 Solution 类：<br>Solution(ListNode head) 使用整数数组初始化对象。<br>int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        self.nodes = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            self.nodes.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.nodes[randint(<span class="number">0</span>, <span class="built_in">len</span>(self.nodes) - <span class="number">1</span>)].val</span><br></pre></td></tr></table></figure>

<h4 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387.字符串中的第一个唯一字符"></a>387.字符串中的第一个唯一字符</h4><p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># list_ = list(s)</span></span><br><span class="line">        <span class="comment"># cnt = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># for c in list_:</span></span><br><span class="line">        <span class="comment">#     cnt[c] = list_.count(c)</span></span><br><span class="line">        <span class="comment"># for key,vaule in cnt.items():</span></span><br><span class="line">        <span class="comment">#     if vaule == 1:</span></span><br><span class="line">        <span class="comment">#         return list_.index(key)</span></span><br><span class="line">        <span class="comment"># return -1</span></span><br><span class="line"></span><br><span class="line">        m = &#123;&#125;</span><br><span class="line">        l_s = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> l_s:</span><br><span class="line">            m[word] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> l_s:</span><br><span class="line">            m[word] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> key,vaule <span class="keyword">in</span> m.items():</span><br><span class="line">            <span class="keyword">if</span> vaule == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> l_s.index(key)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h4><p>给定两个字符串 s 和 t ，它们只包含小写字母。<br>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>请找出在 t 中被添加的字母。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(Counter(t) - Counter(s))[<span class="number">0</span>] </span><br></pre></td></tr></table></figure>

<h4 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434.字符串中的单词数"></a>434.字符串中的单词数</h4><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。<br>请注意，你可以假定字符串里不包括任何不可打印的字符。<br>示例:<br>输入: “Hello, my name is John”<br>输出: 5<br>解释: 这里的单词是指连续的不是空格的字符，所以 “Hello,” 算作 1 个单词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSegments</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.strip()</span><br><span class="line">        s_list = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s)== <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">len</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> s_list <span class="keyword">if</span> <span class="built_in">len</span>(i)&gt;<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>


<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438.找到字符串中所有字母异位词"></a>438.找到字符串中所有字母异位词</h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。<br>示例 1:<br>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findAnagrams(self, s: str, p: str) -&gt; List[int]:</span><br><span class="line">        output, hashmap, hashmap_p = [], &#123;&#125;, &#123;&#125;</span><br><span class="line"></span><br><span class="line">        for char in p:</span><br><span class="line">            hashmap_p[char]=hashmap_p.get(char,0) + 1</span><br><span class="line"></span><br><span class="line">        start=0</span><br><span class="line">        for end in range(len(s)):</span><br><span class="line">            hashmap[s[end]] = hashmap.get(s[end], 0) + 1</span><br><span class="line">            if hashmap == hashmap_p:</span><br><span class="line">                output.append(start)</span><br><span class="line"></span><br><span class="line">            if end&gt;= len(p) -1:</span><br><span class="line">                hashmap[s[start]] -= 1</span><br><span class="line">                if hashmap[s[start]] == 0:</span><br><span class="line">                    del hashmap[s[start]]</span><br><span class="line">                start += 1</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>

<h4 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485.最大连续1的个数"></a>485.最大连续1的个数</h4><p>给定一个二进制数组 nums ， 计算其中最大连续 1 的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result,max_res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[end] ==<span class="number">1</span>:</span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                max_res=<span class="built_in">max</span>(max_res, result)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure>

<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h4><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：<br>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 n ，请计算 F(n) 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">return</span> (self.fib(n-<span class="number">1</span>) + self.fib(n-<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h4 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520.检测大写字母"></a>520.检测大写字母</h4><p>我们定义，在以下情况时，单词的大写用法是正确的：<br>全部字母都是大写，比如 “USA” 。<br>单词中所有字母都不是大写，比如 “leetcode” 。<br>如果单词不只含有一个字母，只有首字母大写， 比如 “Google” 。<br>给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCapitalUse</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span>  <span class="built_in">str</span>.isupper(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">str</span>.islower(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">str</span>.islower(word[<span class="number">1</span>:]) <span class="keyword">and</span> <span class="built_in">str</span>.isupper(word[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542.01 矩阵"></a>542.01 矩阵</h4><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateMatrix</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat <span class="keyword">and</span> mat[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">dir</span> = [(-<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> mat[r][c] == <span class="number">0</span>:</span><br><span class="line">                    queue.append((r, c))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    mat[r][c] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            r, c = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> dr,dc <span class="keyword">in</span> <span class="built_in">dir</span>:</span><br><span class="line">                nr, nc = r + dr, c + dc</span><br><span class="line">                <span class="keyword">if</span> nr &lt; <span class="number">0</span> <span class="keyword">or</span> nr &gt;= m <span class="keyword">or</span> nc &lt; <span class="number">0</span> <span class="keyword">or</span> nc &gt;= n <span class="keyword">or</span> mat[nr][nc] != -<span class="number">1</span>: </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                mat[nr][nc] = mat[r][c] + <span class="number">1</span></span><br><span class="line">                queue.append((nr, nc))</span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>

<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。<br>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。<br>返回矩阵中 省份 的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:</span><br><span class="line">        def dfs(i: int):</span><br><span class="line">            for j in range(cities):</span><br><span class="line">                if isConnected[i][j] == 1 and j not in visited:</span><br><span class="line">                    visited.add(j)</span><br><span class="line">                    dfs(j)</span><br><span class="line"></span><br><span class="line">        cities = len(isConnected)</span><br><span class="line">        visited = set()</span><br><span class="line">        provinces = 0</span><br><span class="line"></span><br><span class="line">        for i in range(cities):</span><br><span class="line">            if i not in visited:</span><br><span class="line">                dfs(i)</span><br><span class="line">                provinces += 1</span><br><span class="line"></span><br><span class="line">        return provinces</span><br></pre></td></tr></table></figure>

<h4 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566.重塑矩阵"></a>566.重塑矩阵</h4><p>在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。<br>给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。<br>如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixReshape</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], r: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(mat) * <span class="built_in">len</span>(mat[<span class="number">0</span>]) != r * c: </span><br><span class="line">            <span class="keyword">return</span> mat</span><br><span class="line">        res, stack = [], []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> mat:</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> row:</span><br><span class="line">                stack.append(e)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) == c:</span><br><span class="line">                    res.append(stack)</span><br><span class="line">                    stack = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567.字符串的排列"></a>567.字符串的排列</h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        hashmap1, hashmap2, result = &#123;&#125;, &#123;&#125;, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s1:</span><br><span class="line">            hashmap1[char] = hashmap1.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s2)):</span><br><span class="line">            hashmap2[s2[end]] = hashmap2.get(s2[end], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hashmap2 == hashmap1:</span><br><span class="line">                result = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end &gt;= <span class="built_in">len</span>(s1) - <span class="number">1</span>:</span><br><span class="line">                hashmap2[s2[start]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap2[s2[start]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> hashmap2[s2[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br></pre></td></tr></table></figure>


<h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a>572.另一棵树的子树</h4><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。<br>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isSubtree(self, s, t):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: TreeNode</span><br><span class="line">        :type t: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not s and not t:</span><br><span class="line">            return True</span><br><span class="line">        if not s or not t:</span><br><span class="line">            return False</span><br><span class="line">        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)</span><br><span class="line"></span><br><span class="line">    def isSameTree(self, s, t):</span><br><span class="line">        if not s and not t:</span><br><span class="line">            return True</span><br><span class="line">        if not s or not t:</span><br><span class="line">            return False</span><br><span class="line">        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h4><p>给你两棵二叉树： root1 和 root2 。<br>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。<br>返回合并后的二叉树。<br>注意: 合并过程必须从两个树的根节点开始。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:        <span class="comment"># 如果 root1 为空，则合并之后节点为 root2</span></span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:        <span class="comment"># 如果 root2 为空，则合并之后节点为 root1</span></span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root = TreeNode(root1.val + root2.val)               <span class="comment"># 如果都存在节点，创建一个新的节点存储合并后的值</span></span><br><span class="line">        root.left = self.mergeTrees(root1.left, root2.left)  <span class="comment"># 递归合并左子树</span></span><br><span class="line">        root.right = self.mergeTrees(root1.right, root2.right)  <span class="comment"># 递归合并右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="627-变更性别"><a href="#627-变更性别" class="headerlink" title="627.变更性别"></a>627.变更性别</h4><p>Salary 表：<br>+————-+———-+<br>| Column Name | Type     |<br>+————-+———-+<br>| id          | int      |<br>| name        | varchar  |<br>| sex         | ENUM     |<br>| salary      | int      |<br>+————-+———-+<br>id 是这个表的主键（具有唯一值的列）。<br>sex 这一列的值是 ENUM 类型，只能从 (‘m’, ‘f’) 中取。<br>本表包含公司雇员的信息。<br>请你编写一个解决方案来交换所有的 ‘f’ 和 ‘m’ （即，将所有 ‘f’ 变为 ‘m’ ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。<br>注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"># update salary set sex = if (sex = &quot;m&quot;, &quot;f&quot;, &quot;m&quot;);</span><br><span class="line"></span><br><span class="line">UPDATE salary</span><br><span class="line">SET</span><br><span class="line">    sex = CASE sex</span><br><span class="line">        WHEN &#x27;m&#x27; THEN &#x27;f&#x27;</span><br><span class="line">        ELSE &#x27;m&#x27;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure>


<h4 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643.子数组最大平均数 I"></a>643.子数组最大平均数 I</h4><p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。<br>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。<br>任何误差小于 10-5 的答案都将被视为正确答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        sum_, max_avg = <span class="number">0</span>, -math.inf</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            <span class="keyword">if</span> end - start + <span class="number">1</span> == k:</span><br><span class="line">                max_avg = <span class="built_in">max</span>(max_avg, sum_ / k)</span><br><span class="line">            <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">                sum_ -= nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_avg</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h4><p>给你一个大小为 m x n 的二进制矩阵 grid 。<br>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>岛屿的面积是岛上值为 1 的单元格的数目。<br>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 遍历二维数组，对于每块土地，去其前后左右找相邻土地，再去前后左右的土地找其前后左右的土地，直到周围没有土地</span></span><br><span class="line"><span class="string">        对于每一块已找过的土地，为避免重复计算，将其置为0</span></span><br><span class="line"><span class="string">        其实就是遍历了所有的岛屿，然后取这些岛屿的最大面积res = max(res, dfs(i, j)) &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n <span class="keyword">and</span> grid[i][j]:</span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dfs(i - <span class="number">1</span>, j) + dfs(i + <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>) + dfs(i, j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dfs(i, j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713.乘积小于 K 的子数组"></a>713.乘积小于 K 的子数组</h4><p>给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。<br>示例 1：<br>输入：nums = [10,5,2,6], k = 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        result, mutil = 0, 1    # Step 1: 定义需要维护的变量</span><br><span class="line">        start = 0                        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            mutil *= nums[end]           # Step 3: 更新需要维护的变量 (min_len, sum_)</span><br><span class="line">            while mutil &gt;= k and start &lt;= end:</span><br><span class="line">                mutil //= nums[start]    </span><br><span class="line">                start += 1</span><br><span class="line">            else:</span><br><span class="line">                result += end-start+1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h4 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728.自除数"></a>728.自除数</h4><p>自除数 是指可以被它包含的每一位数整除的数。<br>例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。<br>自除数 不允许包含 0 。<br>给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]:</span><br><span class="line">        res = []</span><br><span class="line">        for i in range(left,right+1):</span><br><span class="line">            for j in str(i):</span><br><span class="line">                if j==&#x27;0&#x27; or i % int(j)!=0:</span><br><span class="line">                    break</span><br><span class="line">            else:</span><br><span class="line">                res.append(i)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>


<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733.图像渲染"></a>733.图像渲染</h4><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。<br>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。<br>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。<br>最后返回 经过上色渲染后的图像 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">floodFill</span>(<span class="params">self, image: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], sr: <span class="built_in">int</span>, sc: <span class="built_in">int</span>, newColor: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> newColor == image[sr][sc]:  <span class="comment"># 起始颜色和目标颜色相同，则直接返回原图</span></span><br><span class="line">            <span class="keyword">return</span> image</span><br><span class="line">        directions = &#123;(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)&#125;  <span class="comment"># 设置四个方向偏移量，一种常见的省事儿技巧</span></span><br><span class="line">        que = Queue()  <span class="comment"># 构造一个队列，先把起始点放进去</span></span><br><span class="line">        que.put((sr, sc))  <span class="comment"># 记录初始颜色</span></span><br><span class="line">        originalcolor = image[sr][sc]  <span class="comment"># 当队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> que.empty():  <span class="comment"># 取出队列的点并染色</span></span><br><span class="line">            point = que.get()</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor  <span class="comment"># 遍历四个方向</span></span><br><span class="line">            <span class="keyword">for</span> direction <span class="keyword">in</span> directions:  <span class="comment"># 新点是(new_i,new_j)</span></span><br><span class="line">                new_i = point[<span class="number">0</span>] + direction[<span class="number">0</span>]</span><br><span class="line">                new_j = point[<span class="number">1</span>] + direction[<span class="number">1</span>]  <span class="comment"># 如果这个点在定义域内并且它和原来的颜色相同</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= new_i &lt; <span class="built_in">len</span>(image) <span class="keyword">and</span> <span class="number">0</span> &lt;= new_j &lt; <span class="built_in">len</span>(image[<span class="number">0</span>]) <span class="keyword">and</span> image[new_i][new_j] == originalcolor:</span><br><span class="line">                    que.put((new_i, new_j))</span><br><span class="line">        <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>


<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h4><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:</span><br><span class="line">        stack, res = [], [0]* len(temperatures)</span><br><span class="line">        for i , num in enumerate(temperatures):</span><br><span class="line">            while stack and temperatures[stack[-1]]&lt; num:</span><br><span class="line">                index = stack.pop()</span><br><span class="line">                res[index] = i - index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="746-使用最小的花费爬楼梯"><a href="#746-使用最小的花费爬楼梯" class="headerlink" title="746.使用最小的花费爬楼梯"></a>746.使用最小的花费爬楼梯</h4><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。<br>请你计算并返回达到楼梯顶部的最低花费。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cost)==<span class="number">1</span>:<span class="keyword">return</span> cost[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cost)==<span class="number">2</span>:<span class="keyword">return</span> <span class="built_in">min</span>(cost)</span><br><span class="line">        dp=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">len</span>(dp)):</span><br><span class="line">            dp[i]=<span class="built_in">min</span>(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="771-宝石与石头"><a href="#771-宝石与石头" class="headerlink" title="771.宝石与石头"></a>771.宝石与石头</h4><p>给你一个字符串 jewels 代表石头中宝石的类型，另有一个字符串 stones 代表你拥有的石头。 stones 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。<br>字母区分大小写，因此 “a” 和 “A” 是不同类型的石头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numJewelsInStones(self, jewels, stones):</span><br><span class="line">        J = [j for j in jewels]</span><br><span class="line">        S = [s for s in stones]</span><br><span class="line">        res = 0</span><br><span class="line">        for i in range(len(J)):</span><br><span class="line">            res += S.count(J[i])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="784-字母大小全排列"><a href="#784-字母大小全排列" class="headerlink" title="784.字母大小全排列"></a>784.字母大小全排列</h4><p>给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。<br>返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCasePermutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isalpha():</span><br><span class="line">                ans = [a + c.lower() <span class="keyword">for</span> a <span class="keyword">in</span> ans] + [a + c.upper() <span class="keyword">for</span> a <span class="keyword">in</span> ans]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = [a + c <span class="keyword">for</span> a <span class="keyword">in</span> ans]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h4 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796.旋转字符串"></a>796.旋转字符串</h4><p>给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。<br>s 的 旋转操作 就是将 s 最左边的字符移动到最右边。<br>例如, 若 s = ‘abcde’，在旋转一次之后结果就是’bcdea’ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateString</span>(<span class="params">self, s: <span class="built_in">str</span>, goal: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= length:</span><br><span class="line">            s = s[<span class="number">1</span>:]+s[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> s == goal:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a>844. 比较含退格的字符串</h4><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。<br>注意：如果对空文本输入退格字符，文本继续为空。<br>示例 1：<br>输入：s = “ab#c”, t = “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def backspaceCompare(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        def remove_(str_):</span><br><span class="line">            r = []</span><br><span class="line">            for i in range(len(str_)):</span><br><span class="line">                if str_[i] != &#x27;#&#x27;:</span><br><span class="line">                    r.append(str_[i])</span><br><span class="line">                elif str_[i] == &#x27;#&#x27; and len(r)&gt;=1:</span><br><span class="line">                    r.pop()</span><br><span class="line"></span><br><span class="line">            return r</span><br><span class="line"></span><br><span class="line">        return remove_(s) ==remove_(t)</span><br></pre></td></tr></table></figure>

<h4 id="944-腐烂的橘子"><a href="#944-腐烂的橘子" class="headerlink" title="944.腐烂的橘子"></a>944.腐烂的橘子</h4><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">orangesRotting</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        row = <span class="built_in">len</span>(grid)</span><br><span class="line">        col = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        rotten = &#123;(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col) <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>&#125; <span class="comment"># 腐烂集合</span></span><br><span class="line">        fresh = &#123;(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col) <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>&#125;  <span class="comment"># 新鲜集合</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fresh:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rotten: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 即将腐烂的如果在新鲜的集合中，就将它腐烂</span></span><br><span class="line">            rotten = &#123;(i + di, j + dj) <span class="keyword">for</span> i, j <span class="keyword">in</span> rotten <span class="keyword">for</span> di, dj <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)] <span class="keyword">if</span> (i + di, j + dj) <span class="keyword">in</span> fresh&#125; </span><br><span class="line">            fresh -= rotten <span class="comment"># 剔除腐烂的</span></span><br><span class="line">            time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> time</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986.区间列表的交集"></a>986.区间列表的交集</h4><p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。<br>返回这 两个区间列表的交集 。<br>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。<br>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。<br><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png"><br>输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]<br>输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -&gt; List[List[int]]:</span><br><span class="line">        res=[]</span><br><span class="line">        n,m=len(firstList),len(secondList)</span><br><span class="line">        i,j=0,0</span><br><span class="line">        while i&lt;n and j&lt;m:</span><br><span class="line">            left = max(firstList[i][0],secondList[j][0])</span><br><span class="line">            right = min(firstList[i][1],secondList[j][1])</span><br><span class="line">            if left &lt;= right:                         #判断是否有交集的条件</span><br><span class="line">                res.append([left,right])</span><br><span class="line">            if firstList[i][1]&lt;secondList[j][1]:    #哪个右区间元素较小，指针就向前移动一位</span><br><span class="line">                i+=1</span><br><span class="line">            else:e</span><br><span class="line">                j+=1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h4 id="1021-删除最外层的括号"><a href="#1021-删除最外层的括号" class="headerlink" title="1021.删除最外层的括号"></a>1021.删除最外层的括号</h4><p>有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。<br>例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。<br>如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。<br>给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。<br>对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeOuterParentheses</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        m, j, re = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">str</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            m += <span class="number">1</span> <span class="keyword">if</span> S[i]==<span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> m:</span><br><span class="line">                re += S[j+<span class="number">1</span>:i]</span><br><span class="line">                j = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure>



<h4 id="1137-第N个泰波那契数"><a href="#1137-第N个泰波那契数" class="headerlink" title="1137.第N个泰波那契数"></a>1137.第N个泰波那契数</h4><p>泰波那契序列 Tn 定义如下：<br>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2<br>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"><span class="meta">    @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tribonacci</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.tribonacci(n-<span class="number">1</span>) + self.tribonacci(n-<span class="number">2</span>) + self.tribonacci(n-<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1266-访问所有点的最小时间"><a href="#1266-访问所有点的最小时间" class="headerlink" title="1266.访问所有点的最小时间"></a>1266.访问所有点的最小时间</h4><p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。<br>你需要按照下面的规则在平面上移动：<br>每一秒内，你可以：<br>沿水平方向移动一个单位长度，或者<br>沿竖直方向移动一个单位长度，或者<br>跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。<br>在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minTimeToVisitAllPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(points)):</span><br><span class="line">            a = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            b = <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            t = <span class="built_in">max</span>(a,b)</span><br><span class="line">            total += t</span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>


<h4 id="1281-整数的各位积和之差"><a href="#1281-整数的各位积和之差" class="headerlink" title="1281.整数的各位积和之差"></a>1281.整数的各位积和之差</h4><p>给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subtractProductAndSum</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">&quot;*&quot;</span>.join(<span class="built_in">str</span>(n))) - <span class="built_in">eval</span>(<span class="string">&quot;+&quot;</span>.join(<span class="built_in">str</span>(n)))</span><br><span class="line">        <span class="comment"># n = list(str(n))</span></span><br><span class="line">        <span class="comment"># muti = 1</span></span><br><span class="line">        <span class="comment"># summ = 0</span></span><br><span class="line">        <span class="comment"># for i in n:</span></span><br><span class="line">        <span class="comment">#     muti *= int(i)</span></span><br><span class="line">        <span class="comment">#     summ += int(i)</span></span><br><span class="line">        <span class="comment"># return muti-summ</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h4 id="1295-统计位数为偶数的数字"><a href="#1295-统计位数为偶数的数字" class="headerlink" title="1295.统计位数为偶数的数字"></a>1295.统计位数为偶数的数字</h4><p>给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findNumbers(self, nums: List[int]) -&gt; int:</span><br><span class="line">        # res = 0</span><br><span class="line">        # for num in nums:</span><br><span class="line">        #     if len(str(num)) %2 == 0:</span><br><span class="line">        #         res +=1</span><br><span class="line">        # return res</span><br><span class="line">        return sum(map(lambda x: len(str(x)) &amp; 1 ^ 1, nums))</span><br></pre></td></tr></table></figure>

<h4 id="1342-将数字变成0的操作次数"><a href="#1342-将数字变成0的操作次数" class="headerlink" title="1342.将数字变成0的操作次数"></a>1342.将数字变成0的操作次数</h4><p>给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSteps</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num/<span class="number">2</span></span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                num = num - <span class="number">1</span></span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>

<h4 id="1365-有多小于当前数字的数字"><a href="#1365-有多小于当前数字的数字" class="headerlink" title="1365.有多小于当前数字的数字"></a>1365.有多小于当前数字的数字</h4><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。<br>以数组形式返回答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallerNumbersThanCurrent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nums_ = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res.append(nums_.index(i))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="1389-按既定顺序创建目标数组"><a href="#1389-按既定顺序创建目标数组" class="headerlink" title="1389.按既定顺序创建目标数组"></a>1389.按既定顺序创建目标数组</h4><p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：<br>目标数组 target 最初为空。<br>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。<br>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组。<br>题目保证数字插入位置总是存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTargetArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], index: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        target = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            target.insert(index[i],nums[i])</span><br><span class="line">        <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure>
<h4 id="1470-重新排列数组"><a href="#1470-重新排列数组" class="headerlink" title="1470.重新排列数组"></a>1470.重新排列数组</h4><p>给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。<br>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">	def shuffle(self,nums,n):</span><br><span class="line">		nums[::2],nums[1::2] = nums[:n],nums[n:]</span><br><span class="line">		return nums</span><br></pre></td></tr></table></figure>

<h4 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431.拥有最多糖果的孩子"></a>1431.拥有最多糖果的孩子</h4><p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。<br>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kidsWithCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], extraCandies: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        target = <span class="built_in">max</span>(candies)</span><br><span class="line">        <span class="keyword">return</span> [x+extraCandies &gt;= target <span class="keyword">for</span> x <span class="keyword">in</span> candies]</span><br></pre></td></tr></table></figure>

<h4 id="1572-矩阵对角线元素的和"><a href="#1572-矩阵对角线元素的和" class="headerlink" title="1572.矩阵对角线元素的和"></a>1572.矩阵对角线元素的和</h4><p>给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。<br>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diagonalSum</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        mat = np.array(mat)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mat.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mat.shape[<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">if</span> i != j <span class="keyword">and</span> i + j + <span class="number">1</span> != mat.shape[<span class="number">0</span>]:</span><br><span class="line">                    mat[i, j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(np.<span class="built_in">sum</span>(mat))</span><br></pre></td></tr></table></figure>

<h4 id="1603-设计停车系统"><a href="#1603-设计停车系统" class="headerlink" title="1603.设计停车系统"></a>1603.设计停车系统</h4><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。<br>请你实现 ParkingSystem 类：<br>ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。<br>bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。一辆车只能停在  carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParkingSystem</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, big: <span class="built_in">int</span>, medium: <span class="built_in">int</span>, small: <span class="built_in">int</span></span>):</span><br><span class="line">        self.bucket = &#123;<span class="number">1</span>:big, <span class="number">2</span>:medium, <span class="number">3</span>:small&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addCar</span>(<span class="params">self, carType: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> self.bucket[carType] &gt; <span class="number">0</span>:</span><br><span class="line">            self.bucket[carType] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ParkingSystem(big, medium, small)</span></span><br><span class="line"><span class="comment"># param_1 = obj.addCar(carType)</span></span><br></pre></td></tr></table></figure>

<h4 id="1614-括号的最大嵌套深度"><a href="#1614-括号的最大嵌套深度" class="headerlink" title="1614.括号的最大嵌套深度"></a>1614.括号的最大嵌套深度</h4><p>如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：<br>字符串是一个空字符串 “”，或者是一个不为 “(“ 或 “)” 的单字符。<br>字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。<br>字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。<br>类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：<br>depth(“”) = 0<br>depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 “(“ 或者 “)”<br>depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;)&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        dep,m = [],<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> st <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> st == <span class="string">&#x27;(&#x27;</span> : </span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                dep.append(m)</span><br><span class="line">            <span class="keyword">if</span> st == <span class="string">&#x27;)&#x27;</span> : </span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">                dep.append(m)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dep)</span><br><span class="line">        <span class="comment"># try :</span></span><br><span class="line">        <span class="comment">#     return max(dep)</span></span><br><span class="line">        <span class="comment"># except:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br></pre></td></tr></table></figure>

<h4 id="1662-检查两个字符串数组是否相等"><a href="#1662-检查两个字符串数组是否相等" class="headerlink" title="1662.检查两个字符串数组是否相等"></a>1662.检查两个字符串数组是否相等</h4><p>给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。<br>数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrayStringsAreEqual</span>(<span class="params">self, word1: <span class="type">List</span>[<span class="built_in">str</span>], word2: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># word1 = &#x27;&#x27;.join(word1)</span></span><br><span class="line">        <span class="comment"># word2 = &#x27;&#x27;.join(word2)</span></span><br><span class="line">        <span class="comment"># return word1 == word2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(word1) == <span class="string">&#x27;&#x27;</span>.join(word2)</span><br></pre></td></tr></table></figure>

<h4 id="1672-最富有客户的资产数量"><a href="#1672-最富有客户的资产数量" class="headerlink" title="1672.最富有客户的资产数量"></a>1672.最富有客户的资产数量</h4><h4 id="1684-统计一致字符串的数目"><a href="#1684-统计一致字符串的数目" class="headerlink" title="1684.统计一致字符串的数目"></a>1684.统计一致字符串的数目</h4><p>给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。<br>请你返回 words 数组中 一致字符串 的数目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countConsistentStrings</span>(<span class="params">self, allowed: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        num_result = <span class="built_in">len</span>(words) <span class="comment">#默认都是</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> a_char <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span>  allowed.find(a_char)==-<span class="number">1</span>:</span><br><span class="line">                    num_result-=<span class="number">1</span> <span class="comment">#一个字母不在allowed里面 就减去</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> num_result</span><br></pre></td></tr></table></figure>

<h4 id="1695-删除子数组的最大得分"><a href="#1695-删除子数组的最大得分" class="headerlink" title="1695.删除子数组的最大得分"></a>1695.删除子数组的最大得分</h4><p>给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。<br>返回 只删除一个 子数组可获得的 最大得分 。<br>如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximumUniqueSubarray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        sum_,max_sum, hashmap=0, 0, &#123;&#125;</span><br><span class="line">        start = 0</span><br><span class="line">        for end in range(len(nums)):</span><br><span class="line">            sum_ += nums[end]</span><br><span class="line">            hashmap[nums[end]] = hashmap.get(nums[end], 0) + 1</span><br><span class="line">            if hashmap.get(nums[end], 0) &lt; 2:</span><br><span class="line">                max_sum = max(max_sum, sum_)</span><br><span class="line">            while hashmap[nums[end]]&gt;=2:</span><br><span class="line">                head = nums[start]</span><br><span class="line">                sum_ -= head</span><br><span class="line">                hashmap[head] -= 1</span><br><span class="line">                if hashmap[head] ==0:</span><br><span class="line">                    del hashmap[head]</span><br><span class="line">                start += 1</span><br><span class="line">        return max_sum</span><br></pre></td></tr></table></figure>


<h4 id="1773-统计匹配检测规则的物品数量"><a href="#1773-统计匹配检测规则的物品数量" class="headerlink" title="1773.统计匹配检测规则的物品数量"></a>1773.统计匹配检测规则的物品数量</h4><p>给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。<br>另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。<br>如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：<br>ruleKey == “type” 且 ruleValue == typei 。<br>ruleKey == “color” 且 ruleValue == colori 。<br>ruleKey == “name” 且 ruleValue == namei 。<br>统计并返回 匹配检索规则的物品数量 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countMatches</span>(<span class="params">self, items, ruleKey, ruleValue</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type items: List[List[str]]</span></span><br><span class="line"><span class="string">        :type ruleKey: str</span></span><br><span class="line"><span class="string">        :type ruleValue: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rule = &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;color&quot;</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">if</span> item[rule[ruleKey]] == ruleValue:</span><br><span class="line">                i +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i </span><br></pre></td></tr></table></figure>

<h4 id="1822-数组元素积的符号"><a href="#1822-数组元素积的符号" class="headerlink" title="1822.数组元素积的符号"></a>1822.数组元素积的符号</h4><p>已知函数 signFunc(x) 将会根据 x 的正负返回特定值：<br>如果 x 是正数，返回 1 。<br>如果 x 是负数，返回 -1 。<br>如果 x 是等于 0 ，返回 0 。<br>给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。<br>返回 signFunc(product) 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arraySign</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            num *= i</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> num &gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num &lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="1827-最少操作使数组递增"><a href="#1827-最少操作使数组递增" class="headerlink" title="1827.最少操作使数组递增"></a>1827.最少操作使数组递增</h4><p>给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。<br>比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,3,3] 。<br>请你返回使 nums 严格递增 的 最少 操作次数。<br>我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &lt;= i &lt; nums.length - 1 都有 nums[i] &lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums</span>):</span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        left = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            tmp = <span class="built_in">max</span>(left  + <span class="number">1</span>, right)</span><br><span class="line">            ret += tmp - right</span><br><span class="line">            left = tmp </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="1832-判断句子是否为全字母句"><a href="#1832-判断句子是否为全字母句" class="headerlink" title="1832.判断句子是否为全字母句"></a>1832.判断句子是否为全字母句</h4><p>全字母句 指包含英语字母表中每个字母至少一次的句子。<br>给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。<br>如果是，返回 true ；否则，返回 false 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkIfPangram</span>(<span class="params">self, sentence: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># return len(set(list(sentence))) &gt;= 26</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(collections.Counter(sentence)) == <span class="number">26</span></span><br></pre></td></tr></table></figure>


<h4 id="面试题16-08-整数的英语表示"><a href="#面试题16-08-整数的英语表示" class="headerlink" title="面试题16.08.整数的英语表示"></a>面试题16.08.整数的英语表示</h4><p>给定一个整数，打印该整数的英文描述。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberToWords</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        to19 = <span class="string">&#x27;One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve &#x27;</span> \</span><br><span class="line">               <span class="string">&#x27;Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen&#x27;</span>.split()</span><br><span class="line">        tens = <span class="string">&#x27;Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">num</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">return</span> to19[num - <span class="number">1</span>:num]</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">return</span> [tens[num // <span class="number">10</span> - <span class="number">2</span>]] + helper(num  % <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">return</span> [to19[num // <span class="number">100</span> - <span class="number">1</span>]] + [<span class="string">&#x27;Hundred&#x27;</span>] + helper(num % <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">for</span> p, w <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;Thousand&#x27;</span>, <span class="string">&#x27;Million&#x27;</span>, <span class="string">&#x27;Billion&#x27;</span>], <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> num &lt; <span class="number">1000</span> ** (p + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> helper(num // <span class="number">1000</span> ** p) + [w] + helper(num % <span class="number">1000</span> ** p)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(helper(num)) <span class="keyword">or</span> <span class="string">&#x27;Zero&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="LCR28采购方案"><a href="#LCR28采购方案" class="headerlink" title="LCR28采购方案"></a>LCR28采购方案</h4><p>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。<br>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">purchasePlans</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># nums.sort()</span></span><br><span class="line">        <span class="comment"># j = len(nums)</span></span><br><span class="line">        <span class="comment"># while nums[0] + nums[j] &gt;target:</span></span><br><span class="line">        <span class="comment">#     j -= 1</span></span><br><span class="line">        <span class="comment">#     break</span></span><br><span class="line">        <span class="comment"># return (j) % 1000000007</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nums[i]&lt;target:</span><br><span class="line">            index=bisect.bisect_right(nums,target-nums[i])</span><br><span class="line">            <span class="keyword">if</span> index&gt;i:</span><br><span class="line">                ans+=index-i-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h4 id="LCR125-图书整理II"><a href="#LCR125-图书整理II" class="headerlink" title="LCR125.图书整理II"></a>LCR125.图书整理II</h4><p>读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：<br>push(bookID)：把借阅的书籍还到图书馆。<br>pop()：从图书馆中借出书籍。<br>为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。<br>如果没有归还的书可以取出，返回 -1 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack1.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) &gt; <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>

<h4 id="LCR146-螺旋遍历二维数组"><a href="#LCR146-螺旋遍历二维数组" class="headerlink" title="LCR146.螺旋遍历二维数组"></a>LCR146.螺旋遍历二维数组</h4><p>给定一个二维数组 array，请返回「螺旋遍历」该数组的结果。<br>螺旋遍历：从左上角开始，按照 向右、向下、向左、向上 的顺序 依次 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix:[[<span class="built_in">int</span>]]</span>) -&gt; [<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> []</span><br><span class="line">        l, r, t, b, res = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span>, []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, r + <span class="number">1</span>): res.append(matrix[t][i]) <span class="comment"># left to right</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t, b + <span class="number">1</span>): res.append(matrix[i][r]) <span class="comment"># top to bottom</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, l - <span class="number">1</span>, -<span class="number">1</span>): res.append(matrix[b][i]) <span class="comment"># right to left</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b, t - <span class="number">1</span>, -<span class="number">1</span>): res.append(matrix[i][l]) <span class="comment"># bottom to top</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h4 id="LCR147-最小栈"><a href="#LCR147-最小栈" class="headerlink" title="LCR147.最小栈"></a>LCR147.最小栈</h4><p>请你设计一个 最小栈 。它提供 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>        </span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minStack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> self.minStack == [] <span class="keyword">or</span> x &lt; self.<span class="built_in">min</span>():</span><br><span class="line">            self.minStack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = self.<span class="built_in">min</span>()</span><br><span class="line">            self.minStack.append(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack == [] <span class="keyword">or</span> self.minStack == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.minStack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.minStack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure>
<h4 id="LCR159-库存管理III"><a href="#LCR159-库存管理III" class="headerlink" title="LCR159.库存管理III"></a>LCR159.库存管理III</h4><p>仓库管理员以数组 stock 形式记录商品库存表，其中 stock[i] 表示对应商品库存余量。请返回库存余量最少的 cnt 个商品余量，返回 顺序不限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        arr.sort()</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>:k]</span><br></pre></td></tr></table></figure>
<p>####LCR173.点名<br>某班级 n 位同学的学号为 0 ~ n-1。点名结果记录于升序数组 records。假定仅有一位同学缺席，请返回他的学号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># if nums == [1]:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># elif len(nums) == 1:</span></span><br><span class="line">        <span class="comment">#     return nums[0]+1</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     start = nums[0]</span></span><br><span class="line">        <span class="comment">#     end = nums[-1]</span></span><br><span class="line">        <span class="comment">#     re = []</span></span><br><span class="line">        <span class="comment">#     for i in range(start,end+1):</span></span><br><span class="line">        <span class="comment">#         re.append(i)</span></span><br><span class="line">        <span class="comment">#     for i in re:</span></span><br><span class="line">        <span class="comment">#         if i not in nums:</span></span><br><span class="line">        <span class="comment">#             return i </span></span><br><span class="line">        length = <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (length - <span class="number">1</span>) * length // <span class="number">2</span> - <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>


<h4 id="LCR181-字符串中的单词反转"><a href="#LCR181-字符串中的单词反转" class="headerlink" title="LCR181.字符串中的单词反转"></a>LCR181.字符串中的单词反转</h4><p>你在与一位习惯从右往左阅读的朋友发消息，他发出的文字顺序都与正常相反但单词内容正确，为了和他顺利交流你决定写一个转换程序，把他所发的消息 message 转换为正常语序。<br>注意：输入字符串 message 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split()[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h4 id="LCR182-动态口令"><a href="#LCR182-动态口令" class="headerlink" title="LCR182.动态口令"></a>LCR182.动态口令</h4><p>某公司门禁密码使用动态口令技术。初始密码为字符串 password，密码更新均遵循以下步骤：<br>设定一个正整数目标值 target<br>将 password 前 target 个字符按原顺序移动至字符串末尾<br>请返回更新后的密码字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> s[n:]+ s[:n]</span><br></pre></td></tr></table></figure>

<h4 id="LCP01-猜数字"><a href="#LCP01-猜数字" class="headerlink" title="LCP01.猜数字"></a>LCP01.猜数字</h4><p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？<br>输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game</span>(<span class="params">self, guess: <span class="type">List</span>[<span class="built_in">int</span>], answer: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(guess)):</span><br><span class="line">            <span class="keyword">if</span> guess[i] == answer[i]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: res += <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h4 id="LCP06-拿硬币"><a href="#LCP06-拿硬币" class="headerlink" title="LCP06.拿硬币"></a>LCP06.拿硬币</h4><p>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCount</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="built_in">int</span>(i/<span class="number">2</span>) + i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> coins])</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>


<script src="/js/vdonate.js"></script>

<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: 'Donate', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://easylink.cc/e53y50',
  alipayImage: 'https://easylink.cc/fmyobu'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>Post author:  </strong>Bai Xiong</a>
          </li>
          <li class="post-copyright-link">
          <strong>Post link:  </strong>
          <a href="/2023/01/01/DataStructures&algorithms/" target="_blank" title="数据结构和算法题 Data Structures&amp; Algorothms">http://example.com/2023/01/01/DataStructures&algorithms/</a>
          </li>
          <li class="post-copyright-license">
            <strong>Copyright Notice:   </strong>
            All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            unless stating additionally.
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataStructures-Algorothms/" rel="tag">DataStructures&Algorothms</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/01/01/DataStructures&algorithms1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构和算法基础概念 Data Structures&amp; Algorothms
        
      </div>
    </a>
  
  
    <a href="/2022/12/31/DataMining/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据挖掘 DataMining</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.</span> <span class="nav-text">1.两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">2.</span> <span class="nav-text">3.无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">11.盛最多水的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">4.</span> <span class="nav-text">14.最长公共前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">5.</span> <span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">17.电话号码的数字组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">7.</span> <span class="nav-text">19.删除链表的倒数第N个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">8.</span> <span class="nav-text">20.有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">21.合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E6%95%88%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">10.</span> <span class="nav-text">26.删除有效数组中的重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">11.</span> <span class="nav-text">27.移除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">12.</span> <span class="nav-text">33.搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">13.</span> <span class="nav-text">34.在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="nav-number">14.</span> <span class="nav-text">36.有效的数独</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">15.</span> <span class="nav-text">46.全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">16.</span> <span class="nav-text">53.最大子数组和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">17.</span> <span class="nav-text">58.最后一个单词的长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61-%E5%8A%A0%E4%B8%80"><span class="nav-number">18.</span> <span class="nav-text">61.加一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="nav-number">19.</span> <span class="nav-text">67.二进制求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">20.</span> <span class="nav-text">69.x的平方根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">21.</span> <span class="nav-text">70.爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="nav-number">22.</span> <span class="nav-text">73.矩阵置零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="nav-number">23.</span> <span class="nav-text">74.搜索二维矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">24.</span> <span class="nav-text">77.组合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">25.</span> <span class="nav-text">82.删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">26.</span> <span class="nav-text">83.删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">27.</span> <span class="nav-text">88.合并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">28.</span> <span class="nav-text">100.相同的树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">29.</span> <span class="nav-text">111.二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">30.</span> <span class="nav-text">116.填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="nav-number">31.</span> <span class="nav-text">117.填充每个节点的下一个右侧节点指针 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">32.</span> <span class="nav-text">118.杨辉三角</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">33.</span> <span class="nav-text">120.三角形最小路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">34.</span> <span class="nav-text">121.买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="nav-number">35.</span> <span class="nav-text">136.只出现一次的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">36.</span> <span class="nav-text">141.环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="nav-number">37.</span> <span class="nav-text">142.环形链表II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">38.</span> <span class="nav-text">153.寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">39.</span> <span class="nav-text">160.相交链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">40.</span> <span class="nav-text">162.寻找峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">41.</span> <span class="nav-text">169.多数元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#175-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8"><span class="nav-number">42.</span> <span class="nav-text">175.组合两个表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#176-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4"><span class="nav-number">43.</span> <span class="nav-text">176.第二高的薪水</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="nav-number">44.</span> <span class="nav-text">190.颠倒二进制位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">45.</span> <span class="nav-text">191.位1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#193-%E6%9C%89%E6%95%88%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="nav-number">46.</span> <span class="nav-text">193.有效电话号码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1"><span class="nav-number">47.</span> <span class="nav-text">196.删除重复的电子邮箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">48.</span> <span class="nav-text">198.打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">49.</span> <span class="nav-text">200.岛屿数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">50.</span> <span class="nav-text">205.同构字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">51.</span> <span class="nav-text">206.反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">52.</span> <span class="nav-text">209.长度最小的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">53.</span> <span class="nav-text">217.存在重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0II"><span class="nav-number">54.</span> <span class="nav-text">219.存在重复的元素II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#231-2%E7%9A%84%E5%B9%82"><span class="nav-number">55.</span> <span class="nav-text">231.2的幂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="nav-number">56.</span> <span class="nav-text">258.各位相加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#263-%E4%B8%91%E6%95%B0"><span class="nav-number">57.</span> <span class="nav-text">263.丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">58.</span> <span class="nav-text">349.两个数组的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II"><span class="nav-number">59.</span> <span class="nav-text">350.两个数组的交集II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#382-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9"><span class="nav-number">60.</span> <span class="nav-text">382.链表随机节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="nav-number">61.</span> <span class="nav-text">387.字符串中的第一个唯一字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C"><span class="nav-number">62.</span> <span class="nav-text">389.找不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="nav-number">63.</span> <span class="nav-text">434.字符串中的单词数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">64.</span> <span class="nav-text">438.找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">65.</span> <span class="nav-text">485.最大连续1的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">66.</span> <span class="nav-text">509.斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#520-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D"><span class="nav-number">67.</span> <span class="nav-text">520.检测大写字母</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#542-01-%E7%9F%A9%E9%98%B5"><span class="nav-number">68.</span> <span class="nav-text">542.01 矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="nav-number">69.</span> <span class="nav-text">547.省份数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5"><span class="nav-number">70.</span> <span class="nav-text">566.重塑矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">71.</span> <span class="nav-text">567.字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number">72.</span> <span class="nav-text">572.另一棵树的子树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">73.</span> <span class="nav-text">617.合并二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#627-%E5%8F%98%E6%9B%B4%E6%80%A7%E5%88%AB"><span class="nav-number">74.</span> <span class="nav-text">627.变更性别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I"><span class="nav-number">75.</span> <span class="nav-text">643.子数组最大平均数 I</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">76.</span> <span class="nav-text">695.岛屿的最大面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">77.</span> <span class="nav-text">713.乘积小于 K 的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#728-%E8%87%AA%E9%99%A4%E6%95%B0"><span class="nav-number">78.</span> <span class="nav-text">728.自除数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="nav-number">79.</span> <span class="nav-text">733.图像渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">80.</span> <span class="nav-text">739.每日温度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E7%9A%84%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">81.</span> <span class="nav-text">746.使用最小的花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4"><span class="nav-number">82.</span> <span class="nav-text">771.宝石与石头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">83.</span> <span class="nav-text">784.字母大小全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#796-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">84.</span> <span class="nav-text">796.旋转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">85.</span> <span class="nav-text">844. 比较含退格的字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#944-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">86.</span> <span class="nav-text">944.腐烂的橘子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">87.</span> <span class="nav-text">986.区间列表的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1021-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">88.</span> <span class="nav-text">1021.删除最外层的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1137-%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">89.</span> <span class="nav-text">1137.第N个泰波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4"><span class="nav-number">90.</span> <span class="nav-text">1266.访问所有点的最小时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1281-%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE"><span class="nav-number">91.</span> <span class="nav-text">1281.整数的各位积和之差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">92.</span> <span class="nav-text">1295.统计位数为偶数的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1342-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%900%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="nav-number">93.</span> <span class="nav-text">1342.将数字变成0的操作次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1365-%E6%9C%89%E5%A4%9A%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">94.</span> <span class="nav-text">1365.有多小于当前数字的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1389-%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84"><span class="nav-number">95.</span> <span class="nav-text">1389.按既定顺序创建目标数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1470-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84"><span class="nav-number">96.</span> <span class="nav-text">1470.重新排列数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1431-%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90"><span class="nav-number">97.</span> <span class="nav-text">1431.拥有最多糖果的孩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1572-%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C"><span class="nav-number">98.</span> <span class="nav-text">1572.矩阵对角线元素的和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1603-%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F"><span class="nav-number">99.</span> <span class="nav-text">1603.设计停车系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6"><span class="nav-number">100.</span> <span class="nav-text">1614.括号的最大嵌套深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1662-%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="nav-number">101.</span> <span class="nav-text">1662.检查两个字符串数组是否相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1672-%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%95%B0%E9%87%8F"><span class="nav-number">102.</span> <span class="nav-text">1672.最富有客户的资产数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1684-%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-number">103.</span> <span class="nav-text">1684.统计一致字符串的数目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="nav-number">104.</span> <span class="nav-text">1695.删除子数组的最大得分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1773-%E7%BB%9F%E8%AE%A1%E5%8C%B9%E9%85%8D%E6%A3%80%E6%B5%8B%E8%A7%84%E5%88%99%E7%9A%84%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F"><span class="nav-number">105.</span> <span class="nav-text">1773.统计匹配检测规则的物品数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1822-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="nav-number">106.</span> <span class="nav-text">1822.数组元素积的符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1827-%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E6%95%B0%E7%BB%84%E9%80%92%E5%A2%9E"><span class="nav-number">107.</span> <span class="nav-text">1827.最少操作使数组递增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1832-%E5%88%A4%E6%96%AD%E5%8F%A5%E5%AD%90%E6%98%AF%E5%90%A6%E4%B8%BA%E5%85%A8%E5%AD%97%E6%AF%8D%E5%8F%A5"><span class="nav-number">108.</span> <span class="nav-text">1832.判断句子是否为全字母句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9816-08-%E6%95%B4%E6%95%B0%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%A1%A8%E7%A4%BA"><span class="nav-number">109.</span> <span class="nav-text">面试题16.08.整数的英语表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR28%E9%87%87%E8%B4%AD%E6%96%B9%E6%A1%88"><span class="nav-number">110.</span> <span class="nav-text">LCR28采购方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR125-%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%86II"><span class="nav-number">111.</span> <span class="nav-text">LCR125.图书整理II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR146-%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">112.</span> <span class="nav-text">LCR146.螺旋遍历二维数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR147-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">113.</span> <span class="nav-text">LCR147.最小栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR159-%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86III"><span class="nav-number">114.</span> <span class="nav-text">LCR159.库存管理III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR181-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E5%8F%8D%E8%BD%AC"><span class="nav-number">115.</span> <span class="nav-text">LCR181.字符串中的单词反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCR182-%E5%8A%A8%E6%80%81%E5%8F%A3%E4%BB%A4"><span class="nav-number">116.</span> <span class="nav-text">LCR182.动态口令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCP01-%E7%8C%9C%E6%95%B0%E5%AD%97"><span class="nav-number">117.</span> <span class="nav-text">LCP01.猜数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LCP06-%E6%8B%BF%E7%A1%AC%E5%B8%81"><span class="nav-number">118.</span> <span class="nav-text">LCP06.拿硬币</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2024 HELLO WORLD All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				UV : <span id="busuanzi_value_site_uv"></span> |  
				PV : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/collection" class="mobile-nav-link">Collection</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/scripts.js"></script>





  
<script src="/js/dialog.js"></script>









	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            HELLO WORLD
          </div>
          <div class="panel-body">
            Copyright © 2024 Bai Xiong All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>

  <!--单击显示文字-->
  <script type="text/javascript" src="/js/click_show_text.js"></script>

  <!--动态线条背景-->
  <script type="text/javascript"
  color="220,220,220" opacity='0.5' zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
  </script>

  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
